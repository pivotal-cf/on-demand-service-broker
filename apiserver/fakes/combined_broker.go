// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"log"
	"sync"

	"github.com/pivotal-cf/brokerapi/v9/domain"
	"github.com/pivotal-cf/on-demand-service-broker/apiserver"
	"github.com/pivotal-cf/on-demand-service-broker/broker"
	"github.com/pivotal-cf/on-demand-service-broker/cf"
	"github.com/pivotal-cf/on-demand-service-broker/service"
)

type FakeCombinedBroker struct {
	BindStub        func(context.Context, string, string, domain.BindDetails, bool) (domain.Binding, error)
	bindMutex       sync.RWMutex
	bindArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 domain.BindDetails
		arg5 bool
	}
	bindReturns struct {
		result1 domain.Binding
		result2 error
	}
	bindReturnsOnCall map[int]struct {
		result1 domain.Binding
		result2 error
	}
	CountInstancesOfPlansStub        func(*log.Logger) (map[cf.ServicePlan]int, error)
	countInstancesOfPlansMutex       sync.RWMutex
	countInstancesOfPlansArgsForCall []struct {
		arg1 *log.Logger
	}
	countInstancesOfPlansReturns struct {
		result1 map[cf.ServicePlan]int
		result2 error
	}
	countInstancesOfPlansReturnsOnCall map[int]struct {
		result1 map[cf.ServicePlan]int
		result2 error
	}
	DeprovisionStub        func(context.Context, string, domain.DeprovisionDetails, bool) (domain.DeprovisionServiceSpec, error)
	deprovisionMutex       sync.RWMutex
	deprovisionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 domain.DeprovisionDetails
		arg4 bool
	}
	deprovisionReturns struct {
		result1 domain.DeprovisionServiceSpec
		result2 error
	}
	deprovisionReturnsOnCall map[int]struct {
		result1 domain.DeprovisionServiceSpec
		result2 error
	}
	GetBindingStub        func(context.Context, string, string, domain.FetchBindingDetails) (domain.GetBindingSpec, error)
	getBindingMutex       sync.RWMutex
	getBindingArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 domain.FetchBindingDetails
	}
	getBindingReturns struct {
		result1 domain.GetBindingSpec
		result2 error
	}
	getBindingReturnsOnCall map[int]struct {
		result1 domain.GetBindingSpec
		result2 error
	}
	GetInstanceStub        func(context.Context, string, domain.FetchInstanceDetails) (domain.GetInstanceDetailsSpec, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 domain.FetchInstanceDetails
	}
	getInstanceReturns struct {
		result1 domain.GetInstanceDetailsSpec
		result2 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 domain.GetInstanceDetailsSpec
		result2 error
	}
	InstancesStub        func(map[string]string, *log.Logger) ([]service.Instance, error)
	instancesMutex       sync.RWMutex
	instancesArgsForCall []struct {
		arg1 map[string]string
		arg2 *log.Logger
	}
	instancesReturns struct {
		result1 []service.Instance
		result2 error
	}
	instancesReturnsOnCall map[int]struct {
		result1 []service.Instance
		result2 error
	}
	LastBindingOperationStub        func(context.Context, string, string, domain.PollDetails) (domain.LastOperation, error)
	lastBindingOperationMutex       sync.RWMutex
	lastBindingOperationArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 domain.PollDetails
	}
	lastBindingOperationReturns struct {
		result1 domain.LastOperation
		result2 error
	}
	lastBindingOperationReturnsOnCall map[int]struct {
		result1 domain.LastOperation
		result2 error
	}
	LastOperationStub        func(context.Context, string, domain.PollDetails) (domain.LastOperation, error)
	lastOperationMutex       sync.RWMutex
	lastOperationArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 domain.PollDetails
	}
	lastOperationReturns struct {
		result1 domain.LastOperation
		result2 error
	}
	lastOperationReturnsOnCall map[int]struct {
		result1 domain.LastOperation
		result2 error
	}
	OrphanDeploymentsStub        func(*log.Logger) ([]string, error)
	orphanDeploymentsMutex       sync.RWMutex
	orphanDeploymentsArgsForCall []struct {
		arg1 *log.Logger
	}
	orphanDeploymentsReturns struct {
		result1 []string
		result2 error
	}
	orphanDeploymentsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ProvisionStub        func(context.Context, string, domain.ProvisionDetails, bool) (domain.ProvisionedServiceSpec, error)
	provisionMutex       sync.RWMutex
	provisionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 domain.ProvisionDetails
		arg4 bool
	}
	provisionReturns struct {
		result1 domain.ProvisionedServiceSpec
		result2 error
	}
	provisionReturnsOnCall map[int]struct {
		result1 domain.ProvisionedServiceSpec
		result2 error
	}
	RecreateStub        func(context.Context, string, domain.UpdateDetails, *log.Logger) (broker.OperationData, error)
	recreateMutex       sync.RWMutex
	recreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 domain.UpdateDetails
		arg4 *log.Logger
	}
	recreateReturns struct {
		result1 broker.OperationData
		result2 error
	}
	recreateReturnsOnCall map[int]struct {
		result1 broker.OperationData
		result2 error
	}
	ServicesStub        func(context.Context) ([]domain.Service, error)
	servicesMutex       sync.RWMutex
	servicesArgsForCall []struct {
		arg1 context.Context
	}
	servicesReturns struct {
		result1 []domain.Service
		result2 error
	}
	servicesReturnsOnCall map[int]struct {
		result1 []domain.Service
		result2 error
	}
	SetUAAClientStub        func(broker.UAAClient)
	setUAAClientMutex       sync.RWMutex
	setUAAClientArgsForCall []struct {
		arg1 broker.UAAClient
	}
	UnbindStub        func(context.Context, string, string, domain.UnbindDetails, bool) (domain.UnbindSpec, error)
	unbindMutex       sync.RWMutex
	unbindArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 domain.UnbindDetails
		arg5 bool
	}
	unbindReturns struct {
		result1 domain.UnbindSpec
		result2 error
	}
	unbindReturnsOnCall map[int]struct {
		result1 domain.UnbindSpec
		result2 error
	}
	UpdateStub        func(context.Context, string, domain.UpdateDetails, bool) (domain.UpdateServiceSpec, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 domain.UpdateDetails
		arg4 bool
	}
	updateReturns struct {
		result1 domain.UpdateServiceSpec
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 domain.UpdateServiceSpec
		result2 error
	}
	UpgradeStub        func(context.Context, string, domain.UpdateDetails, *log.Logger) (broker.OperationData, string, error)
	upgradeMutex       sync.RWMutex
	upgradeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 domain.UpdateDetails
		arg4 *log.Logger
	}
	upgradeReturns struct {
		result1 broker.OperationData
		result2 string
		result3 error
	}
	upgradeReturnsOnCall map[int]struct {
		result1 broker.OperationData
		result2 string
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCombinedBroker) Bind(arg1 context.Context, arg2 string, arg3 string, arg4 domain.BindDetails, arg5 bool) (domain.Binding, error) {
	fake.bindMutex.Lock()
	ret, specificReturn := fake.bindReturnsOnCall[len(fake.bindArgsForCall)]
	fake.bindArgsForCall = append(fake.bindArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 domain.BindDetails
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.BindStub
	fakeReturns := fake.bindReturns
	fake.recordInvocation("Bind", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.bindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) BindCallCount() int {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return len(fake.bindArgsForCall)
}

func (fake *FakeCombinedBroker) BindCalls(stub func(context.Context, string, string, domain.BindDetails, bool) (domain.Binding, error)) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = stub
}

func (fake *FakeCombinedBroker) BindArgsForCall(i int) (context.Context, string, string, domain.BindDetails, bool) {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	argsForCall := fake.bindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeCombinedBroker) BindReturns(result1 domain.Binding, result2 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	fake.bindReturns = struct {
		result1 domain.Binding
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) BindReturnsOnCall(i int, result1 domain.Binding, result2 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	if fake.bindReturnsOnCall == nil {
		fake.bindReturnsOnCall = make(map[int]struct {
			result1 domain.Binding
			result2 error
		})
	}
	fake.bindReturnsOnCall[i] = struct {
		result1 domain.Binding
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) CountInstancesOfPlans(arg1 *log.Logger) (map[cf.ServicePlan]int, error) {
	fake.countInstancesOfPlansMutex.Lock()
	ret, specificReturn := fake.countInstancesOfPlansReturnsOnCall[len(fake.countInstancesOfPlansArgsForCall)]
	fake.countInstancesOfPlansArgsForCall = append(fake.countInstancesOfPlansArgsForCall, struct {
		arg1 *log.Logger
	}{arg1})
	stub := fake.CountInstancesOfPlansStub
	fakeReturns := fake.countInstancesOfPlansReturns
	fake.recordInvocation("CountInstancesOfPlans", []interface{}{arg1})
	fake.countInstancesOfPlansMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) CountInstancesOfPlansCallCount() int {
	fake.countInstancesOfPlansMutex.RLock()
	defer fake.countInstancesOfPlansMutex.RUnlock()
	return len(fake.countInstancesOfPlansArgsForCall)
}

func (fake *FakeCombinedBroker) CountInstancesOfPlansCalls(stub func(*log.Logger) (map[cf.ServicePlan]int, error)) {
	fake.countInstancesOfPlansMutex.Lock()
	defer fake.countInstancesOfPlansMutex.Unlock()
	fake.CountInstancesOfPlansStub = stub
}

func (fake *FakeCombinedBroker) CountInstancesOfPlansArgsForCall(i int) *log.Logger {
	fake.countInstancesOfPlansMutex.RLock()
	defer fake.countInstancesOfPlansMutex.RUnlock()
	argsForCall := fake.countInstancesOfPlansArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCombinedBroker) CountInstancesOfPlansReturns(result1 map[cf.ServicePlan]int, result2 error) {
	fake.countInstancesOfPlansMutex.Lock()
	defer fake.countInstancesOfPlansMutex.Unlock()
	fake.CountInstancesOfPlansStub = nil
	fake.countInstancesOfPlansReturns = struct {
		result1 map[cf.ServicePlan]int
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) CountInstancesOfPlansReturnsOnCall(i int, result1 map[cf.ServicePlan]int, result2 error) {
	fake.countInstancesOfPlansMutex.Lock()
	defer fake.countInstancesOfPlansMutex.Unlock()
	fake.CountInstancesOfPlansStub = nil
	if fake.countInstancesOfPlansReturnsOnCall == nil {
		fake.countInstancesOfPlansReturnsOnCall = make(map[int]struct {
			result1 map[cf.ServicePlan]int
			result2 error
		})
	}
	fake.countInstancesOfPlansReturnsOnCall[i] = struct {
		result1 map[cf.ServicePlan]int
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) Deprovision(arg1 context.Context, arg2 string, arg3 domain.DeprovisionDetails, arg4 bool) (domain.DeprovisionServiceSpec, error) {
	fake.deprovisionMutex.Lock()
	ret, specificReturn := fake.deprovisionReturnsOnCall[len(fake.deprovisionArgsForCall)]
	fake.deprovisionArgsForCall = append(fake.deprovisionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 domain.DeprovisionDetails
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeprovisionStub
	fakeReturns := fake.deprovisionReturns
	fake.recordInvocation("Deprovision", []interface{}{arg1, arg2, arg3, arg4})
	fake.deprovisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) DeprovisionCallCount() int {
	fake.deprovisionMutex.RLock()
	defer fake.deprovisionMutex.RUnlock()
	return len(fake.deprovisionArgsForCall)
}

func (fake *FakeCombinedBroker) DeprovisionCalls(stub func(context.Context, string, domain.DeprovisionDetails, bool) (domain.DeprovisionServiceSpec, error)) {
	fake.deprovisionMutex.Lock()
	defer fake.deprovisionMutex.Unlock()
	fake.DeprovisionStub = stub
}

func (fake *FakeCombinedBroker) DeprovisionArgsForCall(i int) (context.Context, string, domain.DeprovisionDetails, bool) {
	fake.deprovisionMutex.RLock()
	defer fake.deprovisionMutex.RUnlock()
	argsForCall := fake.deprovisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCombinedBroker) DeprovisionReturns(result1 domain.DeprovisionServiceSpec, result2 error) {
	fake.deprovisionMutex.Lock()
	defer fake.deprovisionMutex.Unlock()
	fake.DeprovisionStub = nil
	fake.deprovisionReturns = struct {
		result1 domain.DeprovisionServiceSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) DeprovisionReturnsOnCall(i int, result1 domain.DeprovisionServiceSpec, result2 error) {
	fake.deprovisionMutex.Lock()
	defer fake.deprovisionMutex.Unlock()
	fake.DeprovisionStub = nil
	if fake.deprovisionReturnsOnCall == nil {
		fake.deprovisionReturnsOnCall = make(map[int]struct {
			result1 domain.DeprovisionServiceSpec
			result2 error
		})
	}
	fake.deprovisionReturnsOnCall[i] = struct {
		result1 domain.DeprovisionServiceSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) GetBinding(arg1 context.Context, arg2 string, arg3 string, arg4 domain.FetchBindingDetails) (domain.GetBindingSpec, error) {
	fake.getBindingMutex.Lock()
	ret, specificReturn := fake.getBindingReturnsOnCall[len(fake.getBindingArgsForCall)]
	fake.getBindingArgsForCall = append(fake.getBindingArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 domain.FetchBindingDetails
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetBindingStub
	fakeReturns := fake.getBindingReturns
	fake.recordInvocation("GetBinding", []interface{}{arg1, arg2, arg3, arg4})
	fake.getBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) GetBindingCallCount() int {
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	return len(fake.getBindingArgsForCall)
}

func (fake *FakeCombinedBroker) GetBindingCalls(stub func(context.Context, string, string, domain.FetchBindingDetails) (domain.GetBindingSpec, error)) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = stub
}

func (fake *FakeCombinedBroker) GetBindingArgsForCall(i int) (context.Context, string, string, domain.FetchBindingDetails) {
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	argsForCall := fake.getBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCombinedBroker) GetBindingReturns(result1 domain.GetBindingSpec, result2 error) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = nil
	fake.getBindingReturns = struct {
		result1 domain.GetBindingSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) GetBindingReturnsOnCall(i int, result1 domain.GetBindingSpec, result2 error) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = nil
	if fake.getBindingReturnsOnCall == nil {
		fake.getBindingReturnsOnCall = make(map[int]struct {
			result1 domain.GetBindingSpec
			result2 error
		})
	}
	fake.getBindingReturnsOnCall[i] = struct {
		result1 domain.GetBindingSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) GetInstance(arg1 context.Context, arg2 string, arg3 domain.FetchInstanceDetails) (domain.GetInstanceDetailsSpec, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 domain.FetchInstanceDetails
	}{arg1, arg2, arg3})
	stub := fake.GetInstanceStub
	fakeReturns := fake.getInstanceReturns
	fake.recordInvocation("GetInstance", []interface{}{arg1, arg2, arg3})
	fake.getInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeCombinedBroker) GetInstanceCalls(stub func(context.Context, string, domain.FetchInstanceDetails) (domain.GetInstanceDetailsSpec, error)) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = stub
}

func (fake *FakeCombinedBroker) GetInstanceArgsForCall(i int) (context.Context, string, domain.FetchInstanceDetails) {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	argsForCall := fake.getInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCombinedBroker) GetInstanceReturns(result1 domain.GetInstanceDetailsSpec, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 domain.GetInstanceDetailsSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) GetInstanceReturnsOnCall(i int, result1 domain.GetInstanceDetailsSpec, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 domain.GetInstanceDetailsSpec
			result2 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 domain.GetInstanceDetailsSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) Instances(arg1 map[string]string, arg2 *log.Logger) ([]service.Instance, error) {
	fake.instancesMutex.Lock()
	ret, specificReturn := fake.instancesReturnsOnCall[len(fake.instancesArgsForCall)]
	fake.instancesArgsForCall = append(fake.instancesArgsForCall, struct {
		arg1 map[string]string
		arg2 *log.Logger
	}{arg1, arg2})
	stub := fake.InstancesStub
	fakeReturns := fake.instancesReturns
	fake.recordInvocation("Instances", []interface{}{arg1, arg2})
	fake.instancesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) InstancesCallCount() int {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return len(fake.instancesArgsForCall)
}

func (fake *FakeCombinedBroker) InstancesCalls(stub func(map[string]string, *log.Logger) ([]service.Instance, error)) {
	fake.instancesMutex.Lock()
	defer fake.instancesMutex.Unlock()
	fake.InstancesStub = stub
}

func (fake *FakeCombinedBroker) InstancesArgsForCall(i int) (map[string]string, *log.Logger) {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	argsForCall := fake.instancesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCombinedBroker) InstancesReturns(result1 []service.Instance, result2 error) {
	fake.instancesMutex.Lock()
	defer fake.instancesMutex.Unlock()
	fake.InstancesStub = nil
	fake.instancesReturns = struct {
		result1 []service.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) InstancesReturnsOnCall(i int, result1 []service.Instance, result2 error) {
	fake.instancesMutex.Lock()
	defer fake.instancesMutex.Unlock()
	fake.InstancesStub = nil
	if fake.instancesReturnsOnCall == nil {
		fake.instancesReturnsOnCall = make(map[int]struct {
			result1 []service.Instance
			result2 error
		})
	}
	fake.instancesReturnsOnCall[i] = struct {
		result1 []service.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) LastBindingOperation(arg1 context.Context, arg2 string, arg3 string, arg4 domain.PollDetails) (domain.LastOperation, error) {
	fake.lastBindingOperationMutex.Lock()
	ret, specificReturn := fake.lastBindingOperationReturnsOnCall[len(fake.lastBindingOperationArgsForCall)]
	fake.lastBindingOperationArgsForCall = append(fake.lastBindingOperationArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 domain.PollDetails
	}{arg1, arg2, arg3, arg4})
	stub := fake.LastBindingOperationStub
	fakeReturns := fake.lastBindingOperationReturns
	fake.recordInvocation("LastBindingOperation", []interface{}{arg1, arg2, arg3, arg4})
	fake.lastBindingOperationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) LastBindingOperationCallCount() int {
	fake.lastBindingOperationMutex.RLock()
	defer fake.lastBindingOperationMutex.RUnlock()
	return len(fake.lastBindingOperationArgsForCall)
}

func (fake *FakeCombinedBroker) LastBindingOperationCalls(stub func(context.Context, string, string, domain.PollDetails) (domain.LastOperation, error)) {
	fake.lastBindingOperationMutex.Lock()
	defer fake.lastBindingOperationMutex.Unlock()
	fake.LastBindingOperationStub = stub
}

func (fake *FakeCombinedBroker) LastBindingOperationArgsForCall(i int) (context.Context, string, string, domain.PollDetails) {
	fake.lastBindingOperationMutex.RLock()
	defer fake.lastBindingOperationMutex.RUnlock()
	argsForCall := fake.lastBindingOperationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCombinedBroker) LastBindingOperationReturns(result1 domain.LastOperation, result2 error) {
	fake.lastBindingOperationMutex.Lock()
	defer fake.lastBindingOperationMutex.Unlock()
	fake.LastBindingOperationStub = nil
	fake.lastBindingOperationReturns = struct {
		result1 domain.LastOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) LastBindingOperationReturnsOnCall(i int, result1 domain.LastOperation, result2 error) {
	fake.lastBindingOperationMutex.Lock()
	defer fake.lastBindingOperationMutex.Unlock()
	fake.LastBindingOperationStub = nil
	if fake.lastBindingOperationReturnsOnCall == nil {
		fake.lastBindingOperationReturnsOnCall = make(map[int]struct {
			result1 domain.LastOperation
			result2 error
		})
	}
	fake.lastBindingOperationReturnsOnCall[i] = struct {
		result1 domain.LastOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) LastOperation(arg1 context.Context, arg2 string, arg3 domain.PollDetails) (domain.LastOperation, error) {
	fake.lastOperationMutex.Lock()
	ret, specificReturn := fake.lastOperationReturnsOnCall[len(fake.lastOperationArgsForCall)]
	fake.lastOperationArgsForCall = append(fake.lastOperationArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 domain.PollDetails
	}{arg1, arg2, arg3})
	stub := fake.LastOperationStub
	fakeReturns := fake.lastOperationReturns
	fake.recordInvocation("LastOperation", []interface{}{arg1, arg2, arg3})
	fake.lastOperationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) LastOperationCallCount() int {
	fake.lastOperationMutex.RLock()
	defer fake.lastOperationMutex.RUnlock()
	return len(fake.lastOperationArgsForCall)
}

func (fake *FakeCombinedBroker) LastOperationCalls(stub func(context.Context, string, domain.PollDetails) (domain.LastOperation, error)) {
	fake.lastOperationMutex.Lock()
	defer fake.lastOperationMutex.Unlock()
	fake.LastOperationStub = stub
}

func (fake *FakeCombinedBroker) LastOperationArgsForCall(i int) (context.Context, string, domain.PollDetails) {
	fake.lastOperationMutex.RLock()
	defer fake.lastOperationMutex.RUnlock()
	argsForCall := fake.lastOperationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCombinedBroker) LastOperationReturns(result1 domain.LastOperation, result2 error) {
	fake.lastOperationMutex.Lock()
	defer fake.lastOperationMutex.Unlock()
	fake.LastOperationStub = nil
	fake.lastOperationReturns = struct {
		result1 domain.LastOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) LastOperationReturnsOnCall(i int, result1 domain.LastOperation, result2 error) {
	fake.lastOperationMutex.Lock()
	defer fake.lastOperationMutex.Unlock()
	fake.LastOperationStub = nil
	if fake.lastOperationReturnsOnCall == nil {
		fake.lastOperationReturnsOnCall = make(map[int]struct {
			result1 domain.LastOperation
			result2 error
		})
	}
	fake.lastOperationReturnsOnCall[i] = struct {
		result1 domain.LastOperation
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) OrphanDeployments(arg1 *log.Logger) ([]string, error) {
	fake.orphanDeploymentsMutex.Lock()
	ret, specificReturn := fake.orphanDeploymentsReturnsOnCall[len(fake.orphanDeploymentsArgsForCall)]
	fake.orphanDeploymentsArgsForCall = append(fake.orphanDeploymentsArgsForCall, struct {
		arg1 *log.Logger
	}{arg1})
	stub := fake.OrphanDeploymentsStub
	fakeReturns := fake.orphanDeploymentsReturns
	fake.recordInvocation("OrphanDeployments", []interface{}{arg1})
	fake.orphanDeploymentsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) OrphanDeploymentsCallCount() int {
	fake.orphanDeploymentsMutex.RLock()
	defer fake.orphanDeploymentsMutex.RUnlock()
	return len(fake.orphanDeploymentsArgsForCall)
}

func (fake *FakeCombinedBroker) OrphanDeploymentsCalls(stub func(*log.Logger) ([]string, error)) {
	fake.orphanDeploymentsMutex.Lock()
	defer fake.orphanDeploymentsMutex.Unlock()
	fake.OrphanDeploymentsStub = stub
}

func (fake *FakeCombinedBroker) OrphanDeploymentsArgsForCall(i int) *log.Logger {
	fake.orphanDeploymentsMutex.RLock()
	defer fake.orphanDeploymentsMutex.RUnlock()
	argsForCall := fake.orphanDeploymentsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCombinedBroker) OrphanDeploymentsReturns(result1 []string, result2 error) {
	fake.orphanDeploymentsMutex.Lock()
	defer fake.orphanDeploymentsMutex.Unlock()
	fake.OrphanDeploymentsStub = nil
	fake.orphanDeploymentsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) OrphanDeploymentsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.orphanDeploymentsMutex.Lock()
	defer fake.orphanDeploymentsMutex.Unlock()
	fake.OrphanDeploymentsStub = nil
	if fake.orphanDeploymentsReturnsOnCall == nil {
		fake.orphanDeploymentsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.orphanDeploymentsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) Provision(arg1 context.Context, arg2 string, arg3 domain.ProvisionDetails, arg4 bool) (domain.ProvisionedServiceSpec, error) {
	fake.provisionMutex.Lock()
	ret, specificReturn := fake.provisionReturnsOnCall[len(fake.provisionArgsForCall)]
	fake.provisionArgsForCall = append(fake.provisionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 domain.ProvisionDetails
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.ProvisionStub
	fakeReturns := fake.provisionReturns
	fake.recordInvocation("Provision", []interface{}{arg1, arg2, arg3, arg4})
	fake.provisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) ProvisionCallCount() int {
	fake.provisionMutex.RLock()
	defer fake.provisionMutex.RUnlock()
	return len(fake.provisionArgsForCall)
}

func (fake *FakeCombinedBroker) ProvisionCalls(stub func(context.Context, string, domain.ProvisionDetails, bool) (domain.ProvisionedServiceSpec, error)) {
	fake.provisionMutex.Lock()
	defer fake.provisionMutex.Unlock()
	fake.ProvisionStub = stub
}

func (fake *FakeCombinedBroker) ProvisionArgsForCall(i int) (context.Context, string, domain.ProvisionDetails, bool) {
	fake.provisionMutex.RLock()
	defer fake.provisionMutex.RUnlock()
	argsForCall := fake.provisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCombinedBroker) ProvisionReturns(result1 domain.ProvisionedServiceSpec, result2 error) {
	fake.provisionMutex.Lock()
	defer fake.provisionMutex.Unlock()
	fake.ProvisionStub = nil
	fake.provisionReturns = struct {
		result1 domain.ProvisionedServiceSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) ProvisionReturnsOnCall(i int, result1 domain.ProvisionedServiceSpec, result2 error) {
	fake.provisionMutex.Lock()
	defer fake.provisionMutex.Unlock()
	fake.ProvisionStub = nil
	if fake.provisionReturnsOnCall == nil {
		fake.provisionReturnsOnCall = make(map[int]struct {
			result1 domain.ProvisionedServiceSpec
			result2 error
		})
	}
	fake.provisionReturnsOnCall[i] = struct {
		result1 domain.ProvisionedServiceSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) Recreate(arg1 context.Context, arg2 string, arg3 domain.UpdateDetails, arg4 *log.Logger) (broker.OperationData, error) {
	fake.recreateMutex.Lock()
	ret, specificReturn := fake.recreateReturnsOnCall[len(fake.recreateArgsForCall)]
	fake.recreateArgsForCall = append(fake.recreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 domain.UpdateDetails
		arg4 *log.Logger
	}{arg1, arg2, arg3, arg4})
	stub := fake.RecreateStub
	fakeReturns := fake.recreateReturns
	fake.recordInvocation("Recreate", []interface{}{arg1, arg2, arg3, arg4})
	fake.recreateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) RecreateCallCount() int {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	return len(fake.recreateArgsForCall)
}

func (fake *FakeCombinedBroker) RecreateCalls(stub func(context.Context, string, domain.UpdateDetails, *log.Logger) (broker.OperationData, error)) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = stub
}

func (fake *FakeCombinedBroker) RecreateArgsForCall(i int) (context.Context, string, domain.UpdateDetails, *log.Logger) {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	argsForCall := fake.recreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCombinedBroker) RecreateReturns(result1 broker.OperationData, result2 error) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = nil
	fake.recreateReturns = struct {
		result1 broker.OperationData
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) RecreateReturnsOnCall(i int, result1 broker.OperationData, result2 error) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = nil
	if fake.recreateReturnsOnCall == nil {
		fake.recreateReturnsOnCall = make(map[int]struct {
			result1 broker.OperationData
			result2 error
		})
	}
	fake.recreateReturnsOnCall[i] = struct {
		result1 broker.OperationData
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) Services(arg1 context.Context) ([]domain.Service, error) {
	fake.servicesMutex.Lock()
	ret, specificReturn := fake.servicesReturnsOnCall[len(fake.servicesArgsForCall)]
	fake.servicesArgsForCall = append(fake.servicesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ServicesStub
	fakeReturns := fake.servicesReturns
	fake.recordInvocation("Services", []interface{}{arg1})
	fake.servicesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) ServicesCallCount() int {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	return len(fake.servicesArgsForCall)
}

func (fake *FakeCombinedBroker) ServicesCalls(stub func(context.Context) ([]domain.Service, error)) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = stub
}

func (fake *FakeCombinedBroker) ServicesArgsForCall(i int) context.Context {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	argsForCall := fake.servicesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCombinedBroker) ServicesReturns(result1 []domain.Service, result2 error) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = nil
	fake.servicesReturns = struct {
		result1 []domain.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) ServicesReturnsOnCall(i int, result1 []domain.Service, result2 error) {
	fake.servicesMutex.Lock()
	defer fake.servicesMutex.Unlock()
	fake.ServicesStub = nil
	if fake.servicesReturnsOnCall == nil {
		fake.servicesReturnsOnCall = make(map[int]struct {
			result1 []domain.Service
			result2 error
		})
	}
	fake.servicesReturnsOnCall[i] = struct {
		result1 []domain.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) SetUAAClient(arg1 broker.UAAClient) {
	fake.setUAAClientMutex.Lock()
	fake.setUAAClientArgsForCall = append(fake.setUAAClientArgsForCall, struct {
		arg1 broker.UAAClient
	}{arg1})
	stub := fake.SetUAAClientStub
	fake.recordInvocation("SetUAAClient", []interface{}{arg1})
	fake.setUAAClientMutex.Unlock()
	if stub != nil {
		fake.SetUAAClientStub(arg1)
	}
}

func (fake *FakeCombinedBroker) SetUAAClientCallCount() int {
	fake.setUAAClientMutex.RLock()
	defer fake.setUAAClientMutex.RUnlock()
	return len(fake.setUAAClientArgsForCall)
}

func (fake *FakeCombinedBroker) SetUAAClientCalls(stub func(broker.UAAClient)) {
	fake.setUAAClientMutex.Lock()
	defer fake.setUAAClientMutex.Unlock()
	fake.SetUAAClientStub = stub
}

func (fake *FakeCombinedBroker) SetUAAClientArgsForCall(i int) broker.UAAClient {
	fake.setUAAClientMutex.RLock()
	defer fake.setUAAClientMutex.RUnlock()
	argsForCall := fake.setUAAClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCombinedBroker) Unbind(arg1 context.Context, arg2 string, arg3 string, arg4 domain.UnbindDetails, arg5 bool) (domain.UnbindSpec, error) {
	fake.unbindMutex.Lock()
	ret, specificReturn := fake.unbindReturnsOnCall[len(fake.unbindArgsForCall)]
	fake.unbindArgsForCall = append(fake.unbindArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 domain.UnbindDetails
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UnbindStub
	fakeReturns := fake.unbindReturns
	fake.recordInvocation("Unbind", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.unbindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) UnbindCallCount() int {
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	return len(fake.unbindArgsForCall)
}

func (fake *FakeCombinedBroker) UnbindCalls(stub func(context.Context, string, string, domain.UnbindDetails, bool) (domain.UnbindSpec, error)) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = stub
}

func (fake *FakeCombinedBroker) UnbindArgsForCall(i int) (context.Context, string, string, domain.UnbindDetails, bool) {
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	argsForCall := fake.unbindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeCombinedBroker) UnbindReturns(result1 domain.UnbindSpec, result2 error) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = nil
	fake.unbindReturns = struct {
		result1 domain.UnbindSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) UnbindReturnsOnCall(i int, result1 domain.UnbindSpec, result2 error) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = nil
	if fake.unbindReturnsOnCall == nil {
		fake.unbindReturnsOnCall = make(map[int]struct {
			result1 domain.UnbindSpec
			result2 error
		})
	}
	fake.unbindReturnsOnCall[i] = struct {
		result1 domain.UnbindSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) Update(arg1 context.Context, arg2 string, arg3 domain.UpdateDetails, arg4 bool) (domain.UpdateServiceSpec, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 domain.UpdateDetails
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCombinedBroker) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeCombinedBroker) UpdateCalls(stub func(context.Context, string, domain.UpdateDetails, bool) (domain.UpdateServiceSpec, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeCombinedBroker) UpdateArgsForCall(i int) (context.Context, string, domain.UpdateDetails, bool) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCombinedBroker) UpdateReturns(result1 domain.UpdateServiceSpec, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 domain.UpdateServiceSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) UpdateReturnsOnCall(i int, result1 domain.UpdateServiceSpec, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 domain.UpdateServiceSpec
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 domain.UpdateServiceSpec
		result2 error
	}{result1, result2}
}

func (fake *FakeCombinedBroker) Upgrade(arg1 context.Context, arg2 string, arg3 domain.UpdateDetails, arg4 *log.Logger) (broker.OperationData, string, error) {
	fake.upgradeMutex.Lock()
	ret, specificReturn := fake.upgradeReturnsOnCall[len(fake.upgradeArgsForCall)]
	fake.upgradeArgsForCall = append(fake.upgradeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 domain.UpdateDetails
		arg4 *log.Logger
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpgradeStub
	fakeReturns := fake.upgradeReturns
	fake.recordInvocation("Upgrade", []interface{}{arg1, arg2, arg3, arg4})
	fake.upgradeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCombinedBroker) UpgradeCallCount() int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return len(fake.upgradeArgsForCall)
}

func (fake *FakeCombinedBroker) UpgradeCalls(stub func(context.Context, string, domain.UpdateDetails, *log.Logger) (broker.OperationData, string, error)) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = stub
}

func (fake *FakeCombinedBroker) UpgradeArgsForCall(i int) (context.Context, string, domain.UpdateDetails, *log.Logger) {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	argsForCall := fake.upgradeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCombinedBroker) UpgradeReturns(result1 broker.OperationData, result2 string, result3 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	fake.upgradeReturns = struct {
		result1 broker.OperationData
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCombinedBroker) UpgradeReturnsOnCall(i int, result1 broker.OperationData, result2 string, result3 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	if fake.upgradeReturnsOnCall == nil {
		fake.upgradeReturnsOnCall = make(map[int]struct {
			result1 broker.OperationData
			result2 string
			result3 error
		})
	}
	fake.upgradeReturnsOnCall[i] = struct {
		result1 broker.OperationData
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCombinedBroker) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	fake.countInstancesOfPlansMutex.RLock()
	defer fake.countInstancesOfPlansMutex.RUnlock()
	fake.deprovisionMutex.RLock()
	defer fake.deprovisionMutex.RUnlock()
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	fake.lastBindingOperationMutex.RLock()
	defer fake.lastBindingOperationMutex.RUnlock()
	fake.lastOperationMutex.RLock()
	defer fake.lastOperationMutex.RUnlock()
	fake.orphanDeploymentsMutex.RLock()
	defer fake.orphanDeploymentsMutex.RUnlock()
	fake.provisionMutex.RLock()
	defer fake.provisionMutex.RUnlock()
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	fake.setUAAClientMutex.RLock()
	defer fake.setUAAClientMutex.RUnlock()
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCombinedBroker) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ apiserver.CombinedBroker = new(FakeCombinedBroker)
