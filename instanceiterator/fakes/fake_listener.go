// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"github.com/pivotal-cf/on-demand-service-broker/broker/services"
	"github.com/pivotal-cf/on-demand-service-broker/config"
	"github.com/pivotal-cf/on-demand-service-broker/instanceiterator"
	"github.com/pivotal-cf/on-demand-service-broker/service"
)

type FakeListener struct {
	CanariesFinishedStub        func()
	canariesFinishedMutex       sync.RWMutex
	canariesFinishedArgsForCall []struct {
	}
	CanariesStartingStub        func(int, config.CanarySelectionParams)
	canariesStartingMutex       sync.RWMutex
	canariesStartingArgsForCall []struct {
		arg1 int
		arg2 config.CanarySelectionParams
	}
	FailedToRefreshInstanceInfoStub        func(string)
	failedToRefreshInstanceInfoMutex       sync.RWMutex
	failedToRefreshInstanceInfoArgsForCall []struct {
		arg1 string
	}
	FinishedStub        func(int, int, int, []string, []string)
	finishedMutex       sync.RWMutex
	finishedArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 int
		arg4 []string
		arg5 []string
	}
	InstanceOperationFinishedStub        func(string, string)
	instanceOperationFinishedMutex       sync.RWMutex
	instanceOperationFinishedArgsForCall []struct {
		arg1 string
		arg2 string
	}
	InstanceOperationStartResultStub        func(string, services.BOSHOperationType)
	instanceOperationStartResultMutex       sync.RWMutex
	instanceOperationStartResultArgsForCall []struct {
		arg1 string
		arg2 services.BOSHOperationType
	}
	InstanceOperationStartingStub        func(string, int, int, bool)
	instanceOperationStartingMutex       sync.RWMutex
	instanceOperationStartingArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 bool
	}
	InstancesToProcessStub        func([]service.Instance)
	instancesToProcessMutex       sync.RWMutex
	instancesToProcessArgsForCall []struct {
		arg1 []service.Instance
	}
	ProgressStub        func(time.Duration, int, int, int, int)
	progressMutex       sync.RWMutex
	progressArgsForCall []struct {
		arg1 time.Duration
		arg2 int
		arg3 int
		arg4 int
		arg5 int
	}
	RetryAttemptStub        func(int, int)
	retryAttemptMutex       sync.RWMutex
	retryAttemptArgsForCall []struct {
		arg1 int
		arg2 int
	}
	RetryCanariesAttemptStub        func(int, int, int)
	retryCanariesAttemptMutex       sync.RWMutex
	retryCanariesAttemptArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 int
	}
	StartingStub        func(int)
	startingMutex       sync.RWMutex
	startingArgsForCall []struct {
		arg1 int
	}
	WaitingForStub        func(string, int)
	waitingForMutex       sync.RWMutex
	waitingForArgsForCall []struct {
		arg1 string
		arg2 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeListener) CanariesFinished() {
	fake.canariesFinishedMutex.Lock()
	fake.canariesFinishedArgsForCall = append(fake.canariesFinishedArgsForCall, struct {
	}{})
	fake.recordInvocation("CanariesFinished", []interface{}{})
	fake.canariesFinishedMutex.Unlock()
	if fake.CanariesFinishedStub != nil {
		fake.CanariesFinishedStub()
	}
}

func (fake *FakeListener) CanariesFinishedCallCount() int {
	fake.canariesFinishedMutex.RLock()
	defer fake.canariesFinishedMutex.RUnlock()
	return len(fake.canariesFinishedArgsForCall)
}

func (fake *FakeListener) CanariesFinishedCalls(stub func()) {
	fake.canariesFinishedMutex.Lock()
	defer fake.canariesFinishedMutex.Unlock()
	fake.CanariesFinishedStub = stub
}

func (fake *FakeListener) CanariesStarting(arg1 int, arg2 config.CanarySelectionParams) {
	fake.canariesStartingMutex.Lock()
	fake.canariesStartingArgsForCall = append(fake.canariesStartingArgsForCall, struct {
		arg1 int
		arg2 config.CanarySelectionParams
	}{arg1, arg2})
	fake.recordInvocation("CanariesStarting", []interface{}{arg1, arg2})
	fake.canariesStartingMutex.Unlock()
	if fake.CanariesStartingStub != nil {
		fake.CanariesStartingStub(arg1, arg2)
	}
}

func (fake *FakeListener) CanariesStartingCallCount() int {
	fake.canariesStartingMutex.RLock()
	defer fake.canariesStartingMutex.RUnlock()
	return len(fake.canariesStartingArgsForCall)
}

func (fake *FakeListener) CanariesStartingCalls(stub func(int, config.CanarySelectionParams)) {
	fake.canariesStartingMutex.Lock()
	defer fake.canariesStartingMutex.Unlock()
	fake.CanariesStartingStub = stub
}

func (fake *FakeListener) CanariesStartingArgsForCall(i int) (int, config.CanarySelectionParams) {
	fake.canariesStartingMutex.RLock()
	defer fake.canariesStartingMutex.RUnlock()
	argsForCall := fake.canariesStartingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) FailedToRefreshInstanceInfo(arg1 string) {
	fake.failedToRefreshInstanceInfoMutex.Lock()
	fake.failedToRefreshInstanceInfoArgsForCall = append(fake.failedToRefreshInstanceInfoArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FailedToRefreshInstanceInfo", []interface{}{arg1})
	fake.failedToRefreshInstanceInfoMutex.Unlock()
	if fake.FailedToRefreshInstanceInfoStub != nil {
		fake.FailedToRefreshInstanceInfoStub(arg1)
	}
}

func (fake *FakeListener) FailedToRefreshInstanceInfoCallCount() int {
	fake.failedToRefreshInstanceInfoMutex.RLock()
	defer fake.failedToRefreshInstanceInfoMutex.RUnlock()
	return len(fake.failedToRefreshInstanceInfoArgsForCall)
}

func (fake *FakeListener) FailedToRefreshInstanceInfoCalls(stub func(string)) {
	fake.failedToRefreshInstanceInfoMutex.Lock()
	defer fake.failedToRefreshInstanceInfoMutex.Unlock()
	fake.FailedToRefreshInstanceInfoStub = stub
}

func (fake *FakeListener) FailedToRefreshInstanceInfoArgsForCall(i int) string {
	fake.failedToRefreshInstanceInfoMutex.RLock()
	defer fake.failedToRefreshInstanceInfoMutex.RUnlock()
	argsForCall := fake.failedToRefreshInstanceInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeListener) Finished(arg1 int, arg2 int, arg3 int, arg4 []string, arg5 []string) {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.finishedMutex.Lock()
	fake.finishedArgsForCall = append(fake.finishedArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 int
		arg4 []string
		arg5 []string
	}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	fake.recordInvocation("Finished", []interface{}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	fake.finishedMutex.Unlock()
	if fake.FinishedStub != nil {
		fake.FinishedStub(arg1, arg2, arg3, arg4, arg5)
	}
}

func (fake *FakeListener) FinishedCallCount() int {
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	return len(fake.finishedArgsForCall)
}

func (fake *FakeListener) FinishedCalls(stub func(int, int, int, []string, []string)) {
	fake.finishedMutex.Lock()
	defer fake.finishedMutex.Unlock()
	fake.FinishedStub = stub
}

func (fake *FakeListener) FinishedArgsForCall(i int) (int, int, int, []string, []string) {
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	argsForCall := fake.finishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeListener) InstanceOperationFinished(arg1 string, arg2 string) {
	fake.instanceOperationFinishedMutex.Lock()
	fake.instanceOperationFinishedArgsForCall = append(fake.instanceOperationFinishedArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("InstanceOperationFinished", []interface{}{arg1, arg2})
	fake.instanceOperationFinishedMutex.Unlock()
	if fake.InstanceOperationFinishedStub != nil {
		fake.InstanceOperationFinishedStub(arg1, arg2)
	}
}

func (fake *FakeListener) InstanceOperationFinishedCallCount() int {
	fake.instanceOperationFinishedMutex.RLock()
	defer fake.instanceOperationFinishedMutex.RUnlock()
	return len(fake.instanceOperationFinishedArgsForCall)
}

func (fake *FakeListener) InstanceOperationFinishedCalls(stub func(string, string)) {
	fake.instanceOperationFinishedMutex.Lock()
	defer fake.instanceOperationFinishedMutex.Unlock()
	fake.InstanceOperationFinishedStub = stub
}

func (fake *FakeListener) InstanceOperationFinishedArgsForCall(i int) (string, string) {
	fake.instanceOperationFinishedMutex.RLock()
	defer fake.instanceOperationFinishedMutex.RUnlock()
	argsForCall := fake.instanceOperationFinishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) InstanceOperationStartResult(arg1 string, arg2 services.BOSHOperationType) {
	fake.instanceOperationStartResultMutex.Lock()
	fake.instanceOperationStartResultArgsForCall = append(fake.instanceOperationStartResultArgsForCall, struct {
		arg1 string
		arg2 services.BOSHOperationType
	}{arg1, arg2})
	fake.recordInvocation("InstanceOperationStartResult", []interface{}{arg1, arg2})
	fake.instanceOperationStartResultMutex.Unlock()
	if fake.InstanceOperationStartResultStub != nil {
		fake.InstanceOperationStartResultStub(arg1, arg2)
	}
}

func (fake *FakeListener) InstanceOperationStartResultCallCount() int {
	fake.instanceOperationStartResultMutex.RLock()
	defer fake.instanceOperationStartResultMutex.RUnlock()
	return len(fake.instanceOperationStartResultArgsForCall)
}

func (fake *FakeListener) InstanceOperationStartResultCalls(stub func(string, services.BOSHOperationType)) {
	fake.instanceOperationStartResultMutex.Lock()
	defer fake.instanceOperationStartResultMutex.Unlock()
	fake.InstanceOperationStartResultStub = stub
}

func (fake *FakeListener) InstanceOperationStartResultArgsForCall(i int) (string, services.BOSHOperationType) {
	fake.instanceOperationStartResultMutex.RLock()
	defer fake.instanceOperationStartResultMutex.RUnlock()
	argsForCall := fake.instanceOperationStartResultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) InstanceOperationStarting(arg1 string, arg2 int, arg3 int, arg4 bool) {
	fake.instanceOperationStartingMutex.Lock()
	fake.instanceOperationStartingArgsForCall = append(fake.instanceOperationStartingArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("InstanceOperationStarting", []interface{}{arg1, arg2, arg3, arg4})
	fake.instanceOperationStartingMutex.Unlock()
	if fake.InstanceOperationStartingStub != nil {
		fake.InstanceOperationStartingStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeListener) InstanceOperationStartingCallCount() int {
	fake.instanceOperationStartingMutex.RLock()
	defer fake.instanceOperationStartingMutex.RUnlock()
	return len(fake.instanceOperationStartingArgsForCall)
}

func (fake *FakeListener) InstanceOperationStartingCalls(stub func(string, int, int, bool)) {
	fake.instanceOperationStartingMutex.Lock()
	defer fake.instanceOperationStartingMutex.Unlock()
	fake.InstanceOperationStartingStub = stub
}

func (fake *FakeListener) InstanceOperationStartingArgsForCall(i int) (string, int, int, bool) {
	fake.instanceOperationStartingMutex.RLock()
	defer fake.instanceOperationStartingMutex.RUnlock()
	argsForCall := fake.instanceOperationStartingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeListener) InstancesToProcess(arg1 []service.Instance) {
	var arg1Copy []service.Instance
	if arg1 != nil {
		arg1Copy = make([]service.Instance, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.instancesToProcessMutex.Lock()
	fake.instancesToProcessArgsForCall = append(fake.instancesToProcessArgsForCall, struct {
		arg1 []service.Instance
	}{arg1Copy})
	fake.recordInvocation("InstancesToProcess", []interface{}{arg1Copy})
	fake.instancesToProcessMutex.Unlock()
	if fake.InstancesToProcessStub != nil {
		fake.InstancesToProcessStub(arg1)
	}
}

func (fake *FakeListener) InstancesToProcessCallCount() int {
	fake.instancesToProcessMutex.RLock()
	defer fake.instancesToProcessMutex.RUnlock()
	return len(fake.instancesToProcessArgsForCall)
}

func (fake *FakeListener) InstancesToProcessCalls(stub func([]service.Instance)) {
	fake.instancesToProcessMutex.Lock()
	defer fake.instancesToProcessMutex.Unlock()
	fake.InstancesToProcessStub = stub
}

func (fake *FakeListener) InstancesToProcessArgsForCall(i int) []service.Instance {
	fake.instancesToProcessMutex.RLock()
	defer fake.instancesToProcessMutex.RUnlock()
	argsForCall := fake.instancesToProcessArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeListener) Progress(arg1 time.Duration, arg2 int, arg3 int, arg4 int, arg5 int) {
	fake.progressMutex.Lock()
	fake.progressArgsForCall = append(fake.progressArgsForCall, struct {
		arg1 time.Duration
		arg2 int
		arg3 int
		arg4 int
		arg5 int
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("Progress", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.progressMutex.Unlock()
	if fake.ProgressStub != nil {
		fake.ProgressStub(arg1, arg2, arg3, arg4, arg5)
	}
}

func (fake *FakeListener) ProgressCallCount() int {
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	return len(fake.progressArgsForCall)
}

func (fake *FakeListener) ProgressCalls(stub func(time.Duration, int, int, int, int)) {
	fake.progressMutex.Lock()
	defer fake.progressMutex.Unlock()
	fake.ProgressStub = stub
}

func (fake *FakeListener) ProgressArgsForCall(i int) (time.Duration, int, int, int, int) {
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	argsForCall := fake.progressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeListener) RetryAttempt(arg1 int, arg2 int) {
	fake.retryAttemptMutex.Lock()
	fake.retryAttemptArgsForCall = append(fake.retryAttemptArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("RetryAttempt", []interface{}{arg1, arg2})
	fake.retryAttemptMutex.Unlock()
	if fake.RetryAttemptStub != nil {
		fake.RetryAttemptStub(arg1, arg2)
	}
}

func (fake *FakeListener) RetryAttemptCallCount() int {
	fake.retryAttemptMutex.RLock()
	defer fake.retryAttemptMutex.RUnlock()
	return len(fake.retryAttemptArgsForCall)
}

func (fake *FakeListener) RetryAttemptCalls(stub func(int, int)) {
	fake.retryAttemptMutex.Lock()
	defer fake.retryAttemptMutex.Unlock()
	fake.RetryAttemptStub = stub
}

func (fake *FakeListener) RetryAttemptArgsForCall(i int) (int, int) {
	fake.retryAttemptMutex.RLock()
	defer fake.retryAttemptMutex.RUnlock()
	argsForCall := fake.retryAttemptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) RetryCanariesAttempt(arg1 int, arg2 int, arg3 int) {
	fake.retryCanariesAttemptMutex.Lock()
	fake.retryCanariesAttemptArgsForCall = append(fake.retryCanariesAttemptArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("RetryCanariesAttempt", []interface{}{arg1, arg2, arg3})
	fake.retryCanariesAttemptMutex.Unlock()
	if fake.RetryCanariesAttemptStub != nil {
		fake.RetryCanariesAttemptStub(arg1, arg2, arg3)
	}
}

func (fake *FakeListener) RetryCanariesAttemptCallCount() int {
	fake.retryCanariesAttemptMutex.RLock()
	defer fake.retryCanariesAttemptMutex.RUnlock()
	return len(fake.retryCanariesAttemptArgsForCall)
}

func (fake *FakeListener) RetryCanariesAttemptCalls(stub func(int, int, int)) {
	fake.retryCanariesAttemptMutex.Lock()
	defer fake.retryCanariesAttemptMutex.Unlock()
	fake.RetryCanariesAttemptStub = stub
}

func (fake *FakeListener) RetryCanariesAttemptArgsForCall(i int) (int, int, int) {
	fake.retryCanariesAttemptMutex.RLock()
	defer fake.retryCanariesAttemptMutex.RUnlock()
	argsForCall := fake.retryCanariesAttemptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeListener) Starting(arg1 int) {
	fake.startingMutex.Lock()
	fake.startingArgsForCall = append(fake.startingArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Starting", []interface{}{arg1})
	fake.startingMutex.Unlock()
	if fake.StartingStub != nil {
		fake.StartingStub(arg1)
	}
}

func (fake *FakeListener) StartingCallCount() int {
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	return len(fake.startingArgsForCall)
}

func (fake *FakeListener) StartingCalls(stub func(int)) {
	fake.startingMutex.Lock()
	defer fake.startingMutex.Unlock()
	fake.StartingStub = stub
}

func (fake *FakeListener) StartingArgsForCall(i int) int {
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	argsForCall := fake.startingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeListener) WaitingFor(arg1 string, arg2 int) {
	fake.waitingForMutex.Lock()
	fake.waitingForArgsForCall = append(fake.waitingForArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("WaitingFor", []interface{}{arg1, arg2})
	fake.waitingForMutex.Unlock()
	if fake.WaitingForStub != nil {
		fake.WaitingForStub(arg1, arg2)
	}
}

func (fake *FakeListener) WaitingForCallCount() int {
	fake.waitingForMutex.RLock()
	defer fake.waitingForMutex.RUnlock()
	return len(fake.waitingForArgsForCall)
}

func (fake *FakeListener) WaitingForCalls(stub func(string, int)) {
	fake.waitingForMutex.Lock()
	defer fake.waitingForMutex.Unlock()
	fake.WaitingForStub = stub
}

func (fake *FakeListener) WaitingForArgsForCall(i int) (string, int) {
	fake.waitingForMutex.RLock()
	defer fake.waitingForMutex.RUnlock()
	argsForCall := fake.waitingForArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.canariesFinishedMutex.RLock()
	defer fake.canariesFinishedMutex.RUnlock()
	fake.canariesStartingMutex.RLock()
	defer fake.canariesStartingMutex.RUnlock()
	fake.failedToRefreshInstanceInfoMutex.RLock()
	defer fake.failedToRefreshInstanceInfoMutex.RUnlock()
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	fake.instanceOperationFinishedMutex.RLock()
	defer fake.instanceOperationFinishedMutex.RUnlock()
	fake.instanceOperationStartResultMutex.RLock()
	defer fake.instanceOperationStartResultMutex.RUnlock()
	fake.instanceOperationStartingMutex.RLock()
	defer fake.instanceOperationStartingMutex.RUnlock()
	fake.instancesToProcessMutex.RLock()
	defer fake.instancesToProcessMutex.RUnlock()
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	fake.retryAttemptMutex.RLock()
	defer fake.retryAttemptMutex.RUnlock()
	fake.retryCanariesAttemptMutex.RLock()
	defer fake.retryCanariesAttemptMutex.RUnlock()
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	fake.waitingForMutex.RLock()
	defer fake.waitingForMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeListener) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ instanceiterator.Listener = new(FakeListener)
