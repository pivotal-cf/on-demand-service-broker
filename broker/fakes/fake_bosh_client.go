// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"log"
	"sync"

	"github.com/pivotal-cf/on-demand-service-broker/boshdirector"
	"github.com/pivotal-cf/on-demand-service-broker/broker"
	"github.com/pivotal-cf/on-demand-service-broker/config"
	"github.com/pivotal-cf/on-demand-services-sdk/bosh"
)

type FakeBoshClient struct {
	DeleteConfigStub        func(string, string, *log.Logger) (bool, error)
	deleteConfigMutex       sync.RWMutex
	deleteConfigArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *log.Logger
	}
	deleteConfigReturns struct {
		result1 bool
		result2 error
	}
	deleteConfigReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteConfigsStub        func(string, *log.Logger) error
	deleteConfigsMutex       sync.RWMutex
	deleteConfigsArgsForCall []struct {
		arg1 string
		arg2 *log.Logger
	}
	deleteConfigsReturns struct {
		result1 error
	}
	deleteConfigsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteDeploymentStub        func(string, string, bool, *boshdirector.AsyncTaskReporter, *log.Logger) (int, error)
	deleteDeploymentMutex       sync.RWMutex
	deleteDeploymentArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 *boshdirector.AsyncTaskReporter
		arg5 *log.Logger
	}
	deleteDeploymentReturns struct {
		result1 int
		result2 error
	}
	deleteDeploymentReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	DeployStub        func([]byte, string, *log.Logger, *boshdirector.AsyncTaskReporter) (int, error)
	deployMutex       sync.RWMutex
	deployArgsForCall []struct {
		arg1 []byte
		arg2 string
		arg3 *log.Logger
		arg4 *boshdirector.AsyncTaskReporter
	}
	deployReturns struct {
		result1 int
		result2 error
	}
	deployReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetConfigsStub        func(string, *log.Logger) ([]boshdirector.BoshConfig, error)
	getConfigsMutex       sync.RWMutex
	getConfigsArgsForCall []struct {
		arg1 string
		arg2 *log.Logger
	}
	getConfigsReturns struct {
		result1 []boshdirector.BoshConfig
		result2 error
	}
	getConfigsReturnsOnCall map[int]struct {
		result1 []boshdirector.BoshConfig
		result2 error
	}
	GetDNSAddressesStub        func(string, []config.BindingDNS) (map[string]string, error)
	getDNSAddressesMutex       sync.RWMutex
	getDNSAddressesArgsForCall []struct {
		arg1 string
		arg2 []config.BindingDNS
	}
	getDNSAddressesReturns struct {
		result1 map[string]string
		result2 error
	}
	getDNSAddressesReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	GetDeploymentStub        func(string, *log.Logger) ([]byte, bool, error)
	getDeploymentMutex       sync.RWMutex
	getDeploymentArgsForCall []struct {
		arg1 string
		arg2 *log.Logger
	}
	getDeploymentReturns struct {
		result1 []byte
		result2 bool
		result3 error
	}
	getDeploymentReturnsOnCall map[int]struct {
		result1 []byte
		result2 bool
		result3 error
	}
	GetDeploymentsStub        func(*log.Logger) ([]boshdirector.Deployment, error)
	getDeploymentsMutex       sync.RWMutex
	getDeploymentsArgsForCall []struct {
		arg1 *log.Logger
	}
	getDeploymentsReturns struct {
		result1 []boshdirector.Deployment
		result2 error
	}
	getDeploymentsReturnsOnCall map[int]struct {
		result1 []boshdirector.Deployment
		result2 error
	}
	GetInfoStub        func(*log.Logger) (boshdirector.Info, error)
	getInfoMutex       sync.RWMutex
	getInfoArgsForCall []struct {
		arg1 *log.Logger
	}
	getInfoReturns struct {
		result1 boshdirector.Info
		result2 error
	}
	getInfoReturnsOnCall map[int]struct {
		result1 boshdirector.Info
		result2 error
	}
	GetNormalisedTasksByContextStub        func(string, string, *log.Logger) (boshdirector.BoshTasks, error)
	getNormalisedTasksByContextMutex       sync.RWMutex
	getNormalisedTasksByContextArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *log.Logger
	}
	getNormalisedTasksByContextReturns struct {
		result1 boshdirector.BoshTasks
		result2 error
	}
	getNormalisedTasksByContextReturnsOnCall map[int]struct {
		result1 boshdirector.BoshTasks
		result2 error
	}
	GetTaskStub        func(int, *log.Logger) (boshdirector.BoshTask, error)
	getTaskMutex       sync.RWMutex
	getTaskArgsForCall []struct {
		arg1 int
		arg2 *log.Logger
	}
	getTaskReturns struct {
		result1 boshdirector.BoshTask
		result2 error
	}
	getTaskReturnsOnCall map[int]struct {
		result1 boshdirector.BoshTask
		result2 error
	}
	GetTasksInProgressStub        func(string, *log.Logger) (boshdirector.BoshTasks, error)
	getTasksInProgressMutex       sync.RWMutex
	getTasksInProgressArgsForCall []struct {
		arg1 string
		arg2 *log.Logger
	}
	getTasksInProgressReturns struct {
		result1 boshdirector.BoshTasks
		result2 error
	}
	getTasksInProgressReturnsOnCall map[int]struct {
		result1 boshdirector.BoshTasks
		result2 error
	}
	RecreateStub        func(string, string, *log.Logger, *boshdirector.AsyncTaskReporter) (int, error)
	recreateMutex       sync.RWMutex
	recreateArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *log.Logger
		arg4 *boshdirector.AsyncTaskReporter
	}
	recreateReturns struct {
		result1 int
		result2 error
	}
	recreateReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	RunErrandStub        func(string, string, []string, string, *log.Logger, *boshdirector.AsyncTaskReporter) (int, error)
	runErrandMutex       sync.RWMutex
	runErrandArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
		arg4 string
		arg5 *log.Logger
		arg6 *boshdirector.AsyncTaskReporter
	}
	runErrandReturns struct {
		result1 int
		result2 error
	}
	runErrandReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	VMsStub        func(string, *log.Logger) (bosh.BoshVMs, error)
	vMsMutex       sync.RWMutex
	vMsArgsForCall []struct {
		arg1 string
		arg2 *log.Logger
	}
	vMsReturns struct {
		result1 bosh.BoshVMs
		result2 error
	}
	vMsReturnsOnCall map[int]struct {
		result1 bosh.BoshVMs
		result2 error
	}
	VariablesStub        func(string, *log.Logger) ([]boshdirector.Variable, error)
	variablesMutex       sync.RWMutex
	variablesArgsForCall []struct {
		arg1 string
		arg2 *log.Logger
	}
	variablesReturns struct {
		result1 []boshdirector.Variable
		result2 error
	}
	variablesReturnsOnCall map[int]struct {
		result1 []boshdirector.Variable
		result2 error
	}
	VerifyAuthStub        func(*log.Logger) error
	verifyAuthMutex       sync.RWMutex
	verifyAuthArgsForCall []struct {
		arg1 *log.Logger
	}
	verifyAuthReturns struct {
		result1 error
	}
	verifyAuthReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBoshClient) DeleteConfig(arg1 string, arg2 string, arg3 *log.Logger) (bool, error) {
	fake.deleteConfigMutex.Lock()
	ret, specificReturn := fake.deleteConfigReturnsOnCall[len(fake.deleteConfigArgsForCall)]
	fake.deleteConfigArgsForCall = append(fake.deleteConfigArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *log.Logger
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteConfig", []interface{}{arg1, arg2, arg3})
	fake.deleteConfigMutex.Unlock()
	if fake.DeleteConfigStub != nil {
		return fake.DeleteConfigStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) DeleteConfigCallCount() int {
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	return len(fake.deleteConfigArgsForCall)
}

func (fake *FakeBoshClient) DeleteConfigCalls(stub func(string, string, *log.Logger) (bool, error)) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = stub
}

func (fake *FakeBoshClient) DeleteConfigArgsForCall(i int) (string, string, *log.Logger) {
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	argsForCall := fake.deleteConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBoshClient) DeleteConfigReturns(result1 bool, result2 error) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = nil
	fake.deleteConfigReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) DeleteConfigReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = nil
	if fake.deleteConfigReturnsOnCall == nil {
		fake.deleteConfigReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteConfigReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) DeleteConfigs(arg1 string, arg2 *log.Logger) error {
	fake.deleteConfigsMutex.Lock()
	ret, specificReturn := fake.deleteConfigsReturnsOnCall[len(fake.deleteConfigsArgsForCall)]
	fake.deleteConfigsArgsForCall = append(fake.deleteConfigsArgsForCall, struct {
		arg1 string
		arg2 *log.Logger
	}{arg1, arg2})
	fake.recordInvocation("DeleteConfigs", []interface{}{arg1, arg2})
	fake.deleteConfigsMutex.Unlock()
	if fake.DeleteConfigsStub != nil {
		return fake.DeleteConfigsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteConfigsReturns
	return fakeReturns.result1
}

func (fake *FakeBoshClient) DeleteConfigsCallCount() int {
	fake.deleteConfigsMutex.RLock()
	defer fake.deleteConfigsMutex.RUnlock()
	return len(fake.deleteConfigsArgsForCall)
}

func (fake *FakeBoshClient) DeleteConfigsCalls(stub func(string, *log.Logger) error) {
	fake.deleteConfigsMutex.Lock()
	defer fake.deleteConfigsMutex.Unlock()
	fake.DeleteConfigsStub = stub
}

func (fake *FakeBoshClient) DeleteConfigsArgsForCall(i int) (string, *log.Logger) {
	fake.deleteConfigsMutex.RLock()
	defer fake.deleteConfigsMutex.RUnlock()
	argsForCall := fake.deleteConfigsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBoshClient) DeleteConfigsReturns(result1 error) {
	fake.deleteConfigsMutex.Lock()
	defer fake.deleteConfigsMutex.Unlock()
	fake.DeleteConfigsStub = nil
	fake.deleteConfigsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBoshClient) DeleteConfigsReturnsOnCall(i int, result1 error) {
	fake.deleteConfigsMutex.Lock()
	defer fake.deleteConfigsMutex.Unlock()
	fake.DeleteConfigsStub = nil
	if fake.deleteConfigsReturnsOnCall == nil {
		fake.deleteConfigsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteConfigsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBoshClient) DeleteDeployment(arg1 string, arg2 string, arg3 bool, arg4 *boshdirector.AsyncTaskReporter, arg5 *log.Logger) (int, error) {
	fake.deleteDeploymentMutex.Lock()
	ret, specificReturn := fake.deleteDeploymentReturnsOnCall[len(fake.deleteDeploymentArgsForCall)]
	fake.deleteDeploymentArgsForCall = append(fake.deleteDeploymentArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 *boshdirector.AsyncTaskReporter
		arg5 *log.Logger
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("DeleteDeployment", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.deleteDeploymentMutex.Unlock()
	if fake.DeleteDeploymentStub != nil {
		return fake.DeleteDeploymentStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteDeploymentReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) DeleteDeploymentCallCount() int {
	fake.deleteDeploymentMutex.RLock()
	defer fake.deleteDeploymentMutex.RUnlock()
	return len(fake.deleteDeploymentArgsForCall)
}

func (fake *FakeBoshClient) DeleteDeploymentCalls(stub func(string, string, bool, *boshdirector.AsyncTaskReporter, *log.Logger) (int, error)) {
	fake.deleteDeploymentMutex.Lock()
	defer fake.deleteDeploymentMutex.Unlock()
	fake.DeleteDeploymentStub = stub
}

func (fake *FakeBoshClient) DeleteDeploymentArgsForCall(i int) (string, string, bool, *boshdirector.AsyncTaskReporter, *log.Logger) {
	fake.deleteDeploymentMutex.RLock()
	defer fake.deleteDeploymentMutex.RUnlock()
	argsForCall := fake.deleteDeploymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeBoshClient) DeleteDeploymentReturns(result1 int, result2 error) {
	fake.deleteDeploymentMutex.Lock()
	defer fake.deleteDeploymentMutex.Unlock()
	fake.DeleteDeploymentStub = nil
	fake.deleteDeploymentReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) DeleteDeploymentReturnsOnCall(i int, result1 int, result2 error) {
	fake.deleteDeploymentMutex.Lock()
	defer fake.deleteDeploymentMutex.Unlock()
	fake.DeleteDeploymentStub = nil
	if fake.deleteDeploymentReturnsOnCall == nil {
		fake.deleteDeploymentReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.deleteDeploymentReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) Deploy(arg1 []byte, arg2 string, arg3 *log.Logger, arg4 *boshdirector.AsyncTaskReporter) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deployMutex.Lock()
	ret, specificReturn := fake.deployReturnsOnCall[len(fake.deployArgsForCall)]
	fake.deployArgsForCall = append(fake.deployArgsForCall, struct {
		arg1 []byte
		arg2 string
		arg3 *log.Logger
		arg4 *boshdirector.AsyncTaskReporter
	}{arg1Copy, arg2, arg3, arg4})
	fake.recordInvocation("Deploy", []interface{}{arg1Copy, arg2, arg3, arg4})
	fake.deployMutex.Unlock()
	if fake.DeployStub != nil {
		return fake.DeployStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deployReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) DeployCallCount() int {
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	return len(fake.deployArgsForCall)
}

func (fake *FakeBoshClient) DeployCalls(stub func([]byte, string, *log.Logger, *boshdirector.AsyncTaskReporter) (int, error)) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = stub
}

func (fake *FakeBoshClient) DeployArgsForCall(i int) ([]byte, string, *log.Logger, *boshdirector.AsyncTaskReporter) {
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	argsForCall := fake.deployArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBoshClient) DeployReturns(result1 int, result2 error) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = nil
	fake.deployReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) DeployReturnsOnCall(i int, result1 int, result2 error) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = nil
	if fake.deployReturnsOnCall == nil {
		fake.deployReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.deployReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetConfigs(arg1 string, arg2 *log.Logger) ([]boshdirector.BoshConfig, error) {
	fake.getConfigsMutex.Lock()
	ret, specificReturn := fake.getConfigsReturnsOnCall[len(fake.getConfigsArgsForCall)]
	fake.getConfigsArgsForCall = append(fake.getConfigsArgsForCall, struct {
		arg1 string
		arg2 *log.Logger
	}{arg1, arg2})
	fake.recordInvocation("GetConfigs", []interface{}{arg1, arg2})
	fake.getConfigsMutex.Unlock()
	if fake.GetConfigsStub != nil {
		return fake.GetConfigsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getConfigsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) GetConfigsCallCount() int {
	fake.getConfigsMutex.RLock()
	defer fake.getConfigsMutex.RUnlock()
	return len(fake.getConfigsArgsForCall)
}

func (fake *FakeBoshClient) GetConfigsCalls(stub func(string, *log.Logger) ([]boshdirector.BoshConfig, error)) {
	fake.getConfigsMutex.Lock()
	defer fake.getConfigsMutex.Unlock()
	fake.GetConfigsStub = stub
}

func (fake *FakeBoshClient) GetConfigsArgsForCall(i int) (string, *log.Logger) {
	fake.getConfigsMutex.RLock()
	defer fake.getConfigsMutex.RUnlock()
	argsForCall := fake.getConfigsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBoshClient) GetConfigsReturns(result1 []boshdirector.BoshConfig, result2 error) {
	fake.getConfigsMutex.Lock()
	defer fake.getConfigsMutex.Unlock()
	fake.GetConfigsStub = nil
	fake.getConfigsReturns = struct {
		result1 []boshdirector.BoshConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetConfigsReturnsOnCall(i int, result1 []boshdirector.BoshConfig, result2 error) {
	fake.getConfigsMutex.Lock()
	defer fake.getConfigsMutex.Unlock()
	fake.GetConfigsStub = nil
	if fake.getConfigsReturnsOnCall == nil {
		fake.getConfigsReturnsOnCall = make(map[int]struct {
			result1 []boshdirector.BoshConfig
			result2 error
		})
	}
	fake.getConfigsReturnsOnCall[i] = struct {
		result1 []boshdirector.BoshConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetDNSAddresses(arg1 string, arg2 []config.BindingDNS) (map[string]string, error) {
	var arg2Copy []config.BindingDNS
	if arg2 != nil {
		arg2Copy = make([]config.BindingDNS, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getDNSAddressesMutex.Lock()
	ret, specificReturn := fake.getDNSAddressesReturnsOnCall[len(fake.getDNSAddressesArgsForCall)]
	fake.getDNSAddressesArgsForCall = append(fake.getDNSAddressesArgsForCall, struct {
		arg1 string
		arg2 []config.BindingDNS
	}{arg1, arg2Copy})
	fake.recordInvocation("GetDNSAddresses", []interface{}{arg1, arg2Copy})
	fake.getDNSAddressesMutex.Unlock()
	if fake.GetDNSAddressesStub != nil {
		return fake.GetDNSAddressesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getDNSAddressesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) GetDNSAddressesCallCount() int {
	fake.getDNSAddressesMutex.RLock()
	defer fake.getDNSAddressesMutex.RUnlock()
	return len(fake.getDNSAddressesArgsForCall)
}

func (fake *FakeBoshClient) GetDNSAddressesCalls(stub func(string, []config.BindingDNS) (map[string]string, error)) {
	fake.getDNSAddressesMutex.Lock()
	defer fake.getDNSAddressesMutex.Unlock()
	fake.GetDNSAddressesStub = stub
}

func (fake *FakeBoshClient) GetDNSAddressesArgsForCall(i int) (string, []config.BindingDNS) {
	fake.getDNSAddressesMutex.RLock()
	defer fake.getDNSAddressesMutex.RUnlock()
	argsForCall := fake.getDNSAddressesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBoshClient) GetDNSAddressesReturns(result1 map[string]string, result2 error) {
	fake.getDNSAddressesMutex.Lock()
	defer fake.getDNSAddressesMutex.Unlock()
	fake.GetDNSAddressesStub = nil
	fake.getDNSAddressesReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetDNSAddressesReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.getDNSAddressesMutex.Lock()
	defer fake.getDNSAddressesMutex.Unlock()
	fake.GetDNSAddressesStub = nil
	if fake.getDNSAddressesReturnsOnCall == nil {
		fake.getDNSAddressesReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.getDNSAddressesReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetDeployment(arg1 string, arg2 *log.Logger) ([]byte, bool, error) {
	fake.getDeploymentMutex.Lock()
	ret, specificReturn := fake.getDeploymentReturnsOnCall[len(fake.getDeploymentArgsForCall)]
	fake.getDeploymentArgsForCall = append(fake.getDeploymentArgsForCall, struct {
		arg1 string
		arg2 *log.Logger
	}{arg1, arg2})
	fake.recordInvocation("GetDeployment", []interface{}{arg1, arg2})
	fake.getDeploymentMutex.Unlock()
	if fake.GetDeploymentStub != nil {
		return fake.GetDeploymentStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getDeploymentReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBoshClient) GetDeploymentCallCount() int {
	fake.getDeploymentMutex.RLock()
	defer fake.getDeploymentMutex.RUnlock()
	return len(fake.getDeploymentArgsForCall)
}

func (fake *FakeBoshClient) GetDeploymentCalls(stub func(string, *log.Logger) ([]byte, bool, error)) {
	fake.getDeploymentMutex.Lock()
	defer fake.getDeploymentMutex.Unlock()
	fake.GetDeploymentStub = stub
}

func (fake *FakeBoshClient) GetDeploymentArgsForCall(i int) (string, *log.Logger) {
	fake.getDeploymentMutex.RLock()
	defer fake.getDeploymentMutex.RUnlock()
	argsForCall := fake.getDeploymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBoshClient) GetDeploymentReturns(result1 []byte, result2 bool, result3 error) {
	fake.getDeploymentMutex.Lock()
	defer fake.getDeploymentMutex.Unlock()
	fake.GetDeploymentStub = nil
	fake.getDeploymentReturns = struct {
		result1 []byte
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBoshClient) GetDeploymentReturnsOnCall(i int, result1 []byte, result2 bool, result3 error) {
	fake.getDeploymentMutex.Lock()
	defer fake.getDeploymentMutex.Unlock()
	fake.GetDeploymentStub = nil
	if fake.getDeploymentReturnsOnCall == nil {
		fake.getDeploymentReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 bool
			result3 error
		})
	}
	fake.getDeploymentReturnsOnCall[i] = struct {
		result1 []byte
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBoshClient) GetDeployments(arg1 *log.Logger) ([]boshdirector.Deployment, error) {
	fake.getDeploymentsMutex.Lock()
	ret, specificReturn := fake.getDeploymentsReturnsOnCall[len(fake.getDeploymentsArgsForCall)]
	fake.getDeploymentsArgsForCall = append(fake.getDeploymentsArgsForCall, struct {
		arg1 *log.Logger
	}{arg1})
	fake.recordInvocation("GetDeployments", []interface{}{arg1})
	fake.getDeploymentsMutex.Unlock()
	if fake.GetDeploymentsStub != nil {
		return fake.GetDeploymentsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getDeploymentsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) GetDeploymentsCallCount() int {
	fake.getDeploymentsMutex.RLock()
	defer fake.getDeploymentsMutex.RUnlock()
	return len(fake.getDeploymentsArgsForCall)
}

func (fake *FakeBoshClient) GetDeploymentsCalls(stub func(*log.Logger) ([]boshdirector.Deployment, error)) {
	fake.getDeploymentsMutex.Lock()
	defer fake.getDeploymentsMutex.Unlock()
	fake.GetDeploymentsStub = stub
}

func (fake *FakeBoshClient) GetDeploymentsArgsForCall(i int) *log.Logger {
	fake.getDeploymentsMutex.RLock()
	defer fake.getDeploymentsMutex.RUnlock()
	argsForCall := fake.getDeploymentsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBoshClient) GetDeploymentsReturns(result1 []boshdirector.Deployment, result2 error) {
	fake.getDeploymentsMutex.Lock()
	defer fake.getDeploymentsMutex.Unlock()
	fake.GetDeploymentsStub = nil
	fake.getDeploymentsReturns = struct {
		result1 []boshdirector.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetDeploymentsReturnsOnCall(i int, result1 []boshdirector.Deployment, result2 error) {
	fake.getDeploymentsMutex.Lock()
	defer fake.getDeploymentsMutex.Unlock()
	fake.GetDeploymentsStub = nil
	if fake.getDeploymentsReturnsOnCall == nil {
		fake.getDeploymentsReturnsOnCall = make(map[int]struct {
			result1 []boshdirector.Deployment
			result2 error
		})
	}
	fake.getDeploymentsReturnsOnCall[i] = struct {
		result1 []boshdirector.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetInfo(arg1 *log.Logger) (boshdirector.Info, error) {
	fake.getInfoMutex.Lock()
	ret, specificReturn := fake.getInfoReturnsOnCall[len(fake.getInfoArgsForCall)]
	fake.getInfoArgsForCall = append(fake.getInfoArgsForCall, struct {
		arg1 *log.Logger
	}{arg1})
	fake.recordInvocation("GetInfo", []interface{}{arg1})
	fake.getInfoMutex.Unlock()
	if fake.GetInfoStub != nil {
		return fake.GetInfoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) GetInfoCallCount() int {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	return len(fake.getInfoArgsForCall)
}

func (fake *FakeBoshClient) GetInfoCalls(stub func(*log.Logger) (boshdirector.Info, error)) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = stub
}

func (fake *FakeBoshClient) GetInfoArgsForCall(i int) *log.Logger {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	argsForCall := fake.getInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBoshClient) GetInfoReturns(result1 boshdirector.Info, result2 error) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = nil
	fake.getInfoReturns = struct {
		result1 boshdirector.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetInfoReturnsOnCall(i int, result1 boshdirector.Info, result2 error) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = nil
	if fake.getInfoReturnsOnCall == nil {
		fake.getInfoReturnsOnCall = make(map[int]struct {
			result1 boshdirector.Info
			result2 error
		})
	}
	fake.getInfoReturnsOnCall[i] = struct {
		result1 boshdirector.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetNormalisedTasksByContext(arg1 string, arg2 string, arg3 *log.Logger) (boshdirector.BoshTasks, error) {
	fake.getNormalisedTasksByContextMutex.Lock()
	ret, specificReturn := fake.getNormalisedTasksByContextReturnsOnCall[len(fake.getNormalisedTasksByContextArgsForCall)]
	fake.getNormalisedTasksByContextArgsForCall = append(fake.getNormalisedTasksByContextArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *log.Logger
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetNormalisedTasksByContext", []interface{}{arg1, arg2, arg3})
	fake.getNormalisedTasksByContextMutex.Unlock()
	if fake.GetNormalisedTasksByContextStub != nil {
		return fake.GetNormalisedTasksByContextStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getNormalisedTasksByContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) GetNormalisedTasksByContextCallCount() int {
	fake.getNormalisedTasksByContextMutex.RLock()
	defer fake.getNormalisedTasksByContextMutex.RUnlock()
	return len(fake.getNormalisedTasksByContextArgsForCall)
}

func (fake *FakeBoshClient) GetNormalisedTasksByContextCalls(stub func(string, string, *log.Logger) (boshdirector.BoshTasks, error)) {
	fake.getNormalisedTasksByContextMutex.Lock()
	defer fake.getNormalisedTasksByContextMutex.Unlock()
	fake.GetNormalisedTasksByContextStub = stub
}

func (fake *FakeBoshClient) GetNormalisedTasksByContextArgsForCall(i int) (string, string, *log.Logger) {
	fake.getNormalisedTasksByContextMutex.RLock()
	defer fake.getNormalisedTasksByContextMutex.RUnlock()
	argsForCall := fake.getNormalisedTasksByContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBoshClient) GetNormalisedTasksByContextReturns(result1 boshdirector.BoshTasks, result2 error) {
	fake.getNormalisedTasksByContextMutex.Lock()
	defer fake.getNormalisedTasksByContextMutex.Unlock()
	fake.GetNormalisedTasksByContextStub = nil
	fake.getNormalisedTasksByContextReturns = struct {
		result1 boshdirector.BoshTasks
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetNormalisedTasksByContextReturnsOnCall(i int, result1 boshdirector.BoshTasks, result2 error) {
	fake.getNormalisedTasksByContextMutex.Lock()
	defer fake.getNormalisedTasksByContextMutex.Unlock()
	fake.GetNormalisedTasksByContextStub = nil
	if fake.getNormalisedTasksByContextReturnsOnCall == nil {
		fake.getNormalisedTasksByContextReturnsOnCall = make(map[int]struct {
			result1 boshdirector.BoshTasks
			result2 error
		})
	}
	fake.getNormalisedTasksByContextReturnsOnCall[i] = struct {
		result1 boshdirector.BoshTasks
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetTask(arg1 int, arg2 *log.Logger) (boshdirector.BoshTask, error) {
	fake.getTaskMutex.Lock()
	ret, specificReturn := fake.getTaskReturnsOnCall[len(fake.getTaskArgsForCall)]
	fake.getTaskArgsForCall = append(fake.getTaskArgsForCall, struct {
		arg1 int
		arg2 *log.Logger
	}{arg1, arg2})
	fake.recordInvocation("GetTask", []interface{}{arg1, arg2})
	fake.getTaskMutex.Unlock()
	if fake.GetTaskStub != nil {
		return fake.GetTaskStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTaskReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) GetTaskCallCount() int {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return len(fake.getTaskArgsForCall)
}

func (fake *FakeBoshClient) GetTaskCalls(stub func(int, *log.Logger) (boshdirector.BoshTask, error)) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = stub
}

func (fake *FakeBoshClient) GetTaskArgsForCall(i int) (int, *log.Logger) {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	argsForCall := fake.getTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBoshClient) GetTaskReturns(result1 boshdirector.BoshTask, result2 error) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	fake.getTaskReturns = struct {
		result1 boshdirector.BoshTask
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetTaskReturnsOnCall(i int, result1 boshdirector.BoshTask, result2 error) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	if fake.getTaskReturnsOnCall == nil {
		fake.getTaskReturnsOnCall = make(map[int]struct {
			result1 boshdirector.BoshTask
			result2 error
		})
	}
	fake.getTaskReturnsOnCall[i] = struct {
		result1 boshdirector.BoshTask
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetTasksInProgress(arg1 string, arg2 *log.Logger) (boshdirector.BoshTasks, error) {
	fake.getTasksInProgressMutex.Lock()
	ret, specificReturn := fake.getTasksInProgressReturnsOnCall[len(fake.getTasksInProgressArgsForCall)]
	fake.getTasksInProgressArgsForCall = append(fake.getTasksInProgressArgsForCall, struct {
		arg1 string
		arg2 *log.Logger
	}{arg1, arg2})
	fake.recordInvocation("GetTasksInProgress", []interface{}{arg1, arg2})
	fake.getTasksInProgressMutex.Unlock()
	if fake.GetTasksInProgressStub != nil {
		return fake.GetTasksInProgressStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTasksInProgressReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) GetTasksInProgressCallCount() int {
	fake.getTasksInProgressMutex.RLock()
	defer fake.getTasksInProgressMutex.RUnlock()
	return len(fake.getTasksInProgressArgsForCall)
}

func (fake *FakeBoshClient) GetTasksInProgressCalls(stub func(string, *log.Logger) (boshdirector.BoshTasks, error)) {
	fake.getTasksInProgressMutex.Lock()
	defer fake.getTasksInProgressMutex.Unlock()
	fake.GetTasksInProgressStub = stub
}

func (fake *FakeBoshClient) GetTasksInProgressArgsForCall(i int) (string, *log.Logger) {
	fake.getTasksInProgressMutex.RLock()
	defer fake.getTasksInProgressMutex.RUnlock()
	argsForCall := fake.getTasksInProgressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBoshClient) GetTasksInProgressReturns(result1 boshdirector.BoshTasks, result2 error) {
	fake.getTasksInProgressMutex.Lock()
	defer fake.getTasksInProgressMutex.Unlock()
	fake.GetTasksInProgressStub = nil
	fake.getTasksInProgressReturns = struct {
		result1 boshdirector.BoshTasks
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) GetTasksInProgressReturnsOnCall(i int, result1 boshdirector.BoshTasks, result2 error) {
	fake.getTasksInProgressMutex.Lock()
	defer fake.getTasksInProgressMutex.Unlock()
	fake.GetTasksInProgressStub = nil
	if fake.getTasksInProgressReturnsOnCall == nil {
		fake.getTasksInProgressReturnsOnCall = make(map[int]struct {
			result1 boshdirector.BoshTasks
			result2 error
		})
	}
	fake.getTasksInProgressReturnsOnCall[i] = struct {
		result1 boshdirector.BoshTasks
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) Recreate(arg1 string, arg2 string, arg3 *log.Logger, arg4 *boshdirector.AsyncTaskReporter) (int, error) {
	fake.recreateMutex.Lock()
	ret, specificReturn := fake.recreateReturnsOnCall[len(fake.recreateArgsForCall)]
	fake.recreateArgsForCall = append(fake.recreateArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *log.Logger
		arg4 *boshdirector.AsyncTaskReporter
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Recreate", []interface{}{arg1, arg2, arg3, arg4})
	fake.recreateMutex.Unlock()
	if fake.RecreateStub != nil {
		return fake.RecreateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.recreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) RecreateCallCount() int {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	return len(fake.recreateArgsForCall)
}

func (fake *FakeBoshClient) RecreateCalls(stub func(string, string, *log.Logger, *boshdirector.AsyncTaskReporter) (int, error)) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = stub
}

func (fake *FakeBoshClient) RecreateArgsForCall(i int) (string, string, *log.Logger, *boshdirector.AsyncTaskReporter) {
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	argsForCall := fake.recreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBoshClient) RecreateReturns(result1 int, result2 error) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = nil
	fake.recreateReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) RecreateReturnsOnCall(i int, result1 int, result2 error) {
	fake.recreateMutex.Lock()
	defer fake.recreateMutex.Unlock()
	fake.RecreateStub = nil
	if fake.recreateReturnsOnCall == nil {
		fake.recreateReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.recreateReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) RunErrand(arg1 string, arg2 string, arg3 []string, arg4 string, arg5 *log.Logger, arg6 *boshdirector.AsyncTaskReporter) (int, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.runErrandMutex.Lock()
	ret, specificReturn := fake.runErrandReturnsOnCall[len(fake.runErrandArgsForCall)]
	fake.runErrandArgsForCall = append(fake.runErrandArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
		arg4 string
		arg5 *log.Logger
		arg6 *boshdirector.AsyncTaskReporter
	}{arg1, arg2, arg3Copy, arg4, arg5, arg6})
	fake.recordInvocation("RunErrand", []interface{}{arg1, arg2, arg3Copy, arg4, arg5, arg6})
	fake.runErrandMutex.Unlock()
	if fake.RunErrandStub != nil {
		return fake.RunErrandStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.runErrandReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) RunErrandCallCount() int {
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	return len(fake.runErrandArgsForCall)
}

func (fake *FakeBoshClient) RunErrandCalls(stub func(string, string, []string, string, *log.Logger, *boshdirector.AsyncTaskReporter) (int, error)) {
	fake.runErrandMutex.Lock()
	defer fake.runErrandMutex.Unlock()
	fake.RunErrandStub = stub
}

func (fake *FakeBoshClient) RunErrandArgsForCall(i int) (string, string, []string, string, *log.Logger, *boshdirector.AsyncTaskReporter) {
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	argsForCall := fake.runErrandArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeBoshClient) RunErrandReturns(result1 int, result2 error) {
	fake.runErrandMutex.Lock()
	defer fake.runErrandMutex.Unlock()
	fake.RunErrandStub = nil
	fake.runErrandReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) RunErrandReturnsOnCall(i int, result1 int, result2 error) {
	fake.runErrandMutex.Lock()
	defer fake.runErrandMutex.Unlock()
	fake.RunErrandStub = nil
	if fake.runErrandReturnsOnCall == nil {
		fake.runErrandReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.runErrandReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) VMs(arg1 string, arg2 *log.Logger) (bosh.BoshVMs, error) {
	fake.vMsMutex.Lock()
	ret, specificReturn := fake.vMsReturnsOnCall[len(fake.vMsArgsForCall)]
	fake.vMsArgsForCall = append(fake.vMsArgsForCall, struct {
		arg1 string
		arg2 *log.Logger
	}{arg1, arg2})
	fake.recordInvocation("VMs", []interface{}{arg1, arg2})
	fake.vMsMutex.Unlock()
	if fake.VMsStub != nil {
		return fake.VMsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.vMsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) VMsCallCount() int {
	fake.vMsMutex.RLock()
	defer fake.vMsMutex.RUnlock()
	return len(fake.vMsArgsForCall)
}

func (fake *FakeBoshClient) VMsCalls(stub func(string, *log.Logger) (bosh.BoshVMs, error)) {
	fake.vMsMutex.Lock()
	defer fake.vMsMutex.Unlock()
	fake.VMsStub = stub
}

func (fake *FakeBoshClient) VMsArgsForCall(i int) (string, *log.Logger) {
	fake.vMsMutex.RLock()
	defer fake.vMsMutex.RUnlock()
	argsForCall := fake.vMsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBoshClient) VMsReturns(result1 bosh.BoshVMs, result2 error) {
	fake.vMsMutex.Lock()
	defer fake.vMsMutex.Unlock()
	fake.VMsStub = nil
	fake.vMsReturns = struct {
		result1 bosh.BoshVMs
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) VMsReturnsOnCall(i int, result1 bosh.BoshVMs, result2 error) {
	fake.vMsMutex.Lock()
	defer fake.vMsMutex.Unlock()
	fake.VMsStub = nil
	if fake.vMsReturnsOnCall == nil {
		fake.vMsReturnsOnCall = make(map[int]struct {
			result1 bosh.BoshVMs
			result2 error
		})
	}
	fake.vMsReturnsOnCall[i] = struct {
		result1 bosh.BoshVMs
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) Variables(arg1 string, arg2 *log.Logger) ([]boshdirector.Variable, error) {
	fake.variablesMutex.Lock()
	ret, specificReturn := fake.variablesReturnsOnCall[len(fake.variablesArgsForCall)]
	fake.variablesArgsForCall = append(fake.variablesArgsForCall, struct {
		arg1 string
		arg2 *log.Logger
	}{arg1, arg2})
	fake.recordInvocation("Variables", []interface{}{arg1, arg2})
	fake.variablesMutex.Unlock()
	if fake.VariablesStub != nil {
		return fake.VariablesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.variablesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBoshClient) VariablesCallCount() int {
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	return len(fake.variablesArgsForCall)
}

func (fake *FakeBoshClient) VariablesCalls(stub func(string, *log.Logger) ([]boshdirector.Variable, error)) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = stub
}

func (fake *FakeBoshClient) VariablesArgsForCall(i int) (string, *log.Logger) {
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	argsForCall := fake.variablesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBoshClient) VariablesReturns(result1 []boshdirector.Variable, result2 error) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = nil
	fake.variablesReturns = struct {
		result1 []boshdirector.Variable
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) VariablesReturnsOnCall(i int, result1 []boshdirector.Variable, result2 error) {
	fake.variablesMutex.Lock()
	defer fake.variablesMutex.Unlock()
	fake.VariablesStub = nil
	if fake.variablesReturnsOnCall == nil {
		fake.variablesReturnsOnCall = make(map[int]struct {
			result1 []boshdirector.Variable
			result2 error
		})
	}
	fake.variablesReturnsOnCall[i] = struct {
		result1 []boshdirector.Variable
		result2 error
	}{result1, result2}
}

func (fake *FakeBoshClient) VerifyAuth(arg1 *log.Logger) error {
	fake.verifyAuthMutex.Lock()
	ret, specificReturn := fake.verifyAuthReturnsOnCall[len(fake.verifyAuthArgsForCall)]
	fake.verifyAuthArgsForCall = append(fake.verifyAuthArgsForCall, struct {
		arg1 *log.Logger
	}{arg1})
	fake.recordInvocation("VerifyAuth", []interface{}{arg1})
	fake.verifyAuthMutex.Unlock()
	if fake.VerifyAuthStub != nil {
		return fake.VerifyAuthStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.verifyAuthReturns
	return fakeReturns.result1
}

func (fake *FakeBoshClient) VerifyAuthCallCount() int {
	fake.verifyAuthMutex.RLock()
	defer fake.verifyAuthMutex.RUnlock()
	return len(fake.verifyAuthArgsForCall)
}

func (fake *FakeBoshClient) VerifyAuthCalls(stub func(*log.Logger) error) {
	fake.verifyAuthMutex.Lock()
	defer fake.verifyAuthMutex.Unlock()
	fake.VerifyAuthStub = stub
}

func (fake *FakeBoshClient) VerifyAuthArgsForCall(i int) *log.Logger {
	fake.verifyAuthMutex.RLock()
	defer fake.verifyAuthMutex.RUnlock()
	argsForCall := fake.verifyAuthArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBoshClient) VerifyAuthReturns(result1 error) {
	fake.verifyAuthMutex.Lock()
	defer fake.verifyAuthMutex.Unlock()
	fake.VerifyAuthStub = nil
	fake.verifyAuthReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBoshClient) VerifyAuthReturnsOnCall(i int, result1 error) {
	fake.verifyAuthMutex.Lock()
	defer fake.verifyAuthMutex.Unlock()
	fake.VerifyAuthStub = nil
	if fake.verifyAuthReturnsOnCall == nil {
		fake.verifyAuthReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyAuthReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBoshClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	fake.deleteConfigsMutex.RLock()
	defer fake.deleteConfigsMutex.RUnlock()
	fake.deleteDeploymentMutex.RLock()
	defer fake.deleteDeploymentMutex.RUnlock()
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	fake.getConfigsMutex.RLock()
	defer fake.getConfigsMutex.RUnlock()
	fake.getDNSAddressesMutex.RLock()
	defer fake.getDNSAddressesMutex.RUnlock()
	fake.getDeploymentMutex.RLock()
	defer fake.getDeploymentMutex.RUnlock()
	fake.getDeploymentsMutex.RLock()
	defer fake.getDeploymentsMutex.RUnlock()
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	fake.getNormalisedTasksByContextMutex.RLock()
	defer fake.getNormalisedTasksByContextMutex.RUnlock()
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	fake.getTasksInProgressMutex.RLock()
	defer fake.getTasksInProgressMutex.RUnlock()
	fake.recreateMutex.RLock()
	defer fake.recreateMutex.RUnlock()
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	fake.vMsMutex.RLock()
	defer fake.vMsMutex.RUnlock()
	fake.variablesMutex.RLock()
	defer fake.variablesMutex.RUnlock()
	fake.verifyAuthMutex.RLock()
	defer fake.verifyAuthMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBoshClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ broker.BoshClient = new(FakeBoshClient)
