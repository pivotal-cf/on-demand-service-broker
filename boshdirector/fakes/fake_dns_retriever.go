// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/pivotal-cf/on-demand-service-broker/boshdirector"
)

type FakeDNSRetriever struct {
	CreateLinkConsumerStub        func(string) (string, error)
	createLinkConsumerMutex       sync.RWMutex
	createLinkConsumerArgsForCall []struct {
		arg1 string
	}
	createLinkConsumerReturns struct {
		result1 string
		result2 error
	}
	createLinkConsumerReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeleteLinkConsumerStub        func(string) error
	deleteLinkConsumerMutex       sync.RWMutex
	deleteLinkConsumerArgsForCall []struct {
		arg1 string
	}
	deleteLinkConsumerReturns struct {
		result1 error
	}
	deleteLinkConsumerReturnsOnCall map[int]struct {
		result1 error
	}
	GetLinkAddressStub        func(string, []string, string) (string, error)
	getLinkAddressMutex       sync.RWMutex
	getLinkAddressArgsForCall []struct {
		arg1 string
		arg2 []string
		arg3 string
	}
	getLinkAddressReturns struct {
		result1 string
		result2 error
	}
	getLinkAddressReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	LinkProviderIDStub        func(string, string, string) (string, error)
	linkProviderIDMutex       sync.RWMutex
	linkProviderIDArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	linkProviderIDReturns struct {
		result1 string
		result2 error
	}
	linkProviderIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDNSRetriever) CreateLinkConsumer(arg1 string) (string, error) {
	fake.createLinkConsumerMutex.Lock()
	ret, specificReturn := fake.createLinkConsumerReturnsOnCall[len(fake.createLinkConsumerArgsForCall)]
	fake.createLinkConsumerArgsForCall = append(fake.createLinkConsumerArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateLinkConsumer", []interface{}{arg1})
	fake.createLinkConsumerMutex.Unlock()
	if fake.CreateLinkConsumerStub != nil {
		return fake.CreateLinkConsumerStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createLinkConsumerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDNSRetriever) CreateLinkConsumerCallCount() int {
	fake.createLinkConsumerMutex.RLock()
	defer fake.createLinkConsumerMutex.RUnlock()
	return len(fake.createLinkConsumerArgsForCall)
}

func (fake *FakeDNSRetriever) CreateLinkConsumerCalls(stub func(string) (string, error)) {
	fake.createLinkConsumerMutex.Lock()
	defer fake.createLinkConsumerMutex.Unlock()
	fake.CreateLinkConsumerStub = stub
}

func (fake *FakeDNSRetriever) CreateLinkConsumerArgsForCall(i int) string {
	fake.createLinkConsumerMutex.RLock()
	defer fake.createLinkConsumerMutex.RUnlock()
	argsForCall := fake.createLinkConsumerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDNSRetriever) CreateLinkConsumerReturns(result1 string, result2 error) {
	fake.createLinkConsumerMutex.Lock()
	defer fake.createLinkConsumerMutex.Unlock()
	fake.CreateLinkConsumerStub = nil
	fake.createLinkConsumerReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDNSRetriever) CreateLinkConsumerReturnsOnCall(i int, result1 string, result2 error) {
	fake.createLinkConsumerMutex.Lock()
	defer fake.createLinkConsumerMutex.Unlock()
	fake.CreateLinkConsumerStub = nil
	if fake.createLinkConsumerReturnsOnCall == nil {
		fake.createLinkConsumerReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createLinkConsumerReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDNSRetriever) DeleteLinkConsumer(arg1 string) error {
	fake.deleteLinkConsumerMutex.Lock()
	ret, specificReturn := fake.deleteLinkConsumerReturnsOnCall[len(fake.deleteLinkConsumerArgsForCall)]
	fake.deleteLinkConsumerArgsForCall = append(fake.deleteLinkConsumerArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteLinkConsumer", []interface{}{arg1})
	fake.deleteLinkConsumerMutex.Unlock()
	if fake.DeleteLinkConsumerStub != nil {
		return fake.DeleteLinkConsumerStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteLinkConsumerReturns
	return fakeReturns.result1
}

func (fake *FakeDNSRetriever) DeleteLinkConsumerCallCount() int {
	fake.deleteLinkConsumerMutex.RLock()
	defer fake.deleteLinkConsumerMutex.RUnlock()
	return len(fake.deleteLinkConsumerArgsForCall)
}

func (fake *FakeDNSRetriever) DeleteLinkConsumerCalls(stub func(string) error) {
	fake.deleteLinkConsumerMutex.Lock()
	defer fake.deleteLinkConsumerMutex.Unlock()
	fake.DeleteLinkConsumerStub = stub
}

func (fake *FakeDNSRetriever) DeleteLinkConsumerArgsForCall(i int) string {
	fake.deleteLinkConsumerMutex.RLock()
	defer fake.deleteLinkConsumerMutex.RUnlock()
	argsForCall := fake.deleteLinkConsumerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDNSRetriever) DeleteLinkConsumerReturns(result1 error) {
	fake.deleteLinkConsumerMutex.Lock()
	defer fake.deleteLinkConsumerMutex.Unlock()
	fake.DeleteLinkConsumerStub = nil
	fake.deleteLinkConsumerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDNSRetriever) DeleteLinkConsumerReturnsOnCall(i int, result1 error) {
	fake.deleteLinkConsumerMutex.Lock()
	defer fake.deleteLinkConsumerMutex.Unlock()
	fake.DeleteLinkConsumerStub = nil
	if fake.deleteLinkConsumerReturnsOnCall == nil {
		fake.deleteLinkConsumerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteLinkConsumerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDNSRetriever) GetLinkAddress(arg1 string, arg2 []string, arg3 string) (string, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getLinkAddressMutex.Lock()
	ret, specificReturn := fake.getLinkAddressReturnsOnCall[len(fake.getLinkAddressArgsForCall)]
	fake.getLinkAddressArgsForCall = append(fake.getLinkAddressArgsForCall, struct {
		arg1 string
		arg2 []string
		arg3 string
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("GetLinkAddress", []interface{}{arg1, arg2Copy, arg3})
	fake.getLinkAddressMutex.Unlock()
	if fake.GetLinkAddressStub != nil {
		return fake.GetLinkAddressStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getLinkAddressReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDNSRetriever) GetLinkAddressCallCount() int {
	fake.getLinkAddressMutex.RLock()
	defer fake.getLinkAddressMutex.RUnlock()
	return len(fake.getLinkAddressArgsForCall)
}

func (fake *FakeDNSRetriever) GetLinkAddressCalls(stub func(string, []string, string) (string, error)) {
	fake.getLinkAddressMutex.Lock()
	defer fake.getLinkAddressMutex.Unlock()
	fake.GetLinkAddressStub = stub
}

func (fake *FakeDNSRetriever) GetLinkAddressArgsForCall(i int) (string, []string, string) {
	fake.getLinkAddressMutex.RLock()
	defer fake.getLinkAddressMutex.RUnlock()
	argsForCall := fake.getLinkAddressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDNSRetriever) GetLinkAddressReturns(result1 string, result2 error) {
	fake.getLinkAddressMutex.Lock()
	defer fake.getLinkAddressMutex.Unlock()
	fake.GetLinkAddressStub = nil
	fake.getLinkAddressReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDNSRetriever) GetLinkAddressReturnsOnCall(i int, result1 string, result2 error) {
	fake.getLinkAddressMutex.Lock()
	defer fake.getLinkAddressMutex.Unlock()
	fake.GetLinkAddressStub = nil
	if fake.getLinkAddressReturnsOnCall == nil {
		fake.getLinkAddressReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getLinkAddressReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDNSRetriever) LinkProviderID(arg1 string, arg2 string, arg3 string) (string, error) {
	fake.linkProviderIDMutex.Lock()
	ret, specificReturn := fake.linkProviderIDReturnsOnCall[len(fake.linkProviderIDArgsForCall)]
	fake.linkProviderIDArgsForCall = append(fake.linkProviderIDArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("LinkProviderID", []interface{}{arg1, arg2, arg3})
	fake.linkProviderIDMutex.Unlock()
	if fake.LinkProviderIDStub != nil {
		return fake.LinkProviderIDStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.linkProviderIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDNSRetriever) LinkProviderIDCallCount() int {
	fake.linkProviderIDMutex.RLock()
	defer fake.linkProviderIDMutex.RUnlock()
	return len(fake.linkProviderIDArgsForCall)
}

func (fake *FakeDNSRetriever) LinkProviderIDCalls(stub func(string, string, string) (string, error)) {
	fake.linkProviderIDMutex.Lock()
	defer fake.linkProviderIDMutex.Unlock()
	fake.LinkProviderIDStub = stub
}

func (fake *FakeDNSRetriever) LinkProviderIDArgsForCall(i int) (string, string, string) {
	fake.linkProviderIDMutex.RLock()
	defer fake.linkProviderIDMutex.RUnlock()
	argsForCall := fake.linkProviderIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDNSRetriever) LinkProviderIDReturns(result1 string, result2 error) {
	fake.linkProviderIDMutex.Lock()
	defer fake.linkProviderIDMutex.Unlock()
	fake.LinkProviderIDStub = nil
	fake.linkProviderIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDNSRetriever) LinkProviderIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.linkProviderIDMutex.Lock()
	defer fake.linkProviderIDMutex.Unlock()
	fake.LinkProviderIDStub = nil
	if fake.linkProviderIDReturnsOnCall == nil {
		fake.linkProviderIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.linkProviderIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDNSRetriever) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createLinkConsumerMutex.RLock()
	defer fake.createLinkConsumerMutex.RUnlock()
	fake.deleteLinkConsumerMutex.RLock()
	defer fake.deleteLinkConsumerMutex.RUnlock()
	fake.getLinkAddressMutex.RLock()
	defer fake.getLinkAddressMutex.RUnlock()
	fake.linkProviderIDMutex.RLock()
	defer fake.linkProviderIDMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDNSRetriever) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ boshdirector.DNSRetriever = new(FakeDNSRetriever)
